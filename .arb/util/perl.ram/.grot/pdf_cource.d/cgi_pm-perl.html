<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<TITLE>CGI.pm - библиотека CGI для Perl 5</TITLE>
<META name="author" content="Шмидт Павел Владимирович">
</HEAD>
<body bgcolor="#DDE1C2">
<!--#include virtual="/header.raw"-->
<h3>Версия для печати</h3>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/141.shtml">Perl</a>"
</b>
 <small>(<a href="./">Многостраничная версия</a>)</small>
<hr noshade size=1>

<a name="index_html"></a>
<H1>CGI.pm - библиотека CGI для Perl5</H1>
<P>Версия&nbsp;2.56, 13.09.1999, Л. Штейн. Перевод 13.02.2000, П. Шмидт.
<H2>Резюме</H2>
<P>Эта библиотека для Perl&nbsp;5 использует объекты, чтобы создавать заполняемые формы для Web "на лету" и делать грамматический разбор их содержимого. Она обеспечивает простой интерфейс для грамматического разбора и интерпретации строк запросов, переданных в скрипты CGI. Однако она также предлагает богатый набор функций для создания заполняемых форм. Вместо запоминания синтаксиса для элементов форм HTML, вы просто делаете последовательности вызовов функций Perl. Дополнительное преимущество этого - то, что значение предыдущего запроса используется, чтобы инициировать форму, таким образом, состояние формы сохраняется от вызова к вызову.
<P>Все делается через объект "CGI". Когда вы создаете один из этих объектов, он осматривает окружение на предмет строки запроса, делает ее синтаксический разбор и хранит результаты. Вы можете попросить объект CGI вернуть или изменить значения запроса. Объекты CGI корректно обращаются с методами POST и GET и корректно находят различия между скриптами, вызванными из документов &lt;ISINDEX&gt; и документов, основанных на формах. Фактически вы можете отслеживать (debug) ваш скрипт из командной строки, не заботясь об установке переменных окружения.
<P>Скрипт, чтобы создать заполняемую форму, которая помнит свое состояние каждый раз, когда он вызывается, очень просто написать, используя CGI.pm:
<PRE>
  #!/usr/local/bin/perl
  use CGI qw(:standard);

  print header;
  print start_html('Простой пример'),
    h1('Простой пример'),
    start_form,
    'Как вас зовут? ',textfield('имя'),
    p,
    'Какая комбинация?',
    p,
    checkbox_group(-name=&gt;'слова',
                   -values=&gt;['eenie','meenie','minie','moe'],
                   -defaults=&gt;['eenie','minie']),
    p,
    'Какой ваш любимый цвет? ',
    popup_menu(-name=&gt;'цвет',
               -values=&gt;['красный','зеленый','синий','желтовато-зеленый']),
    p,
    submit,
    end_form,
    hr;

  if(param()) {
    print 'Ваше имя - ',em(param('имя')),
      p,
      'Ключевые слова: ',em(join(", ",param('слова'))),
      p,
      'Ваш любимый цвет - ',em(param('цвет')),
      hr
  }
  print end_html;
</PRE>
<P><A href="http://stein.cshl.org/WWW/software/CGI/examples/tryit.cgi">Выберите эту ссылку, чтобы испробовать скрипт</A><BR>
<A href="http://stein.cshl.org/WWW/software/CGI/examples/">Еще примеры скриптов</A><BR>
<A href="http://www.wiley.com/compbooks/stein/source.html">Примеры исходных кодов из <CITE>Официального руководства к CGI.pm</CITE></A>
<H2><A name="index_html_contents">Содержание</A></H2>
<MENU>
  <LI><P><A href="#index_html_installation">Загрузка и установка</A>
  <LI><P><A href="#index_html_functionvsoo">Функционально-ориентированное использование в сравнении с объектно-ориентированным</A>
  <LI><P><A href="#index_html_query">Создание нового объекта запроса CGI</A>
  <LI><P><A href="#index_html_saving">Сохранение состояния формы</A>
  <LI><P><A href="#index_html_named_param">Функции CGI, которые принимают множество аргументов</A>
  <LI><P><A href="#index_html_header">Создание заголовка HTTP</A>
  <LI><P><A href="#index_html_html">Ярлыки HTML</A>
  <LI><P><A href="#index_html_forms">Создание форм</A>
  <LI><P><A href="#index_html_import">Импортирование методов CGI</A>
  <LI><P><A href="#index_html_errors">Возвращение ошибок CGI.pm</A>
  <LI><P><A href="#index_html_debugging">Отслеживание (debugging)</A>
  <LI><P><A href="#index_html_environment">Переменные сессии HTTP</A>
  <LI><P><A href="#index_html_cookies">HTTP Cookies</A>
  <LI><P><A href="#index_html_frames">Поддержка кадров (frame)</A>
  <LI><P><A href="#index_html_javascripting">Поддержка JavaScript</A>
  <LI><P><A href="#index_html_stylesheets">Ограниченная поддержка каскадных таблиц стилей</A>
  <LI><P><A href="#index_html_nph">Использование скриптов NPH</A>
  <LI><P><A href="#index_html_advanced">Продвинутые приемы</A>
  <LI><P><A href="#index_html_subclassing">Subclassing CGI.pm</A>
  <LI><P><A href="#index_html_mod_perl">Использование CGI.pm с mod_perl и FastCGI</A>
  <LI><P><A href="#index_html_migrating">Миграция из cgi-lib.pl</A>
  <LI><P><A href="#index_html_upload_caveats">Использование особенности для выгрузки файлов</A>
  <LI><P><A href="#index_html_push">Server Push</A>
  <LI><P><A href="#index_html_dos">Avoiding Denial of Service Attacks</A>
  <LI><P><A href="#index_html_non_unix">Использование CGI.pm на платформах не-Unix</A>
  <LI><P><A href="#index_html_future">Отношение CGI.pm к модулям CGI::*</A>
  <LI><P><A href="#index_html_distribution">Информация о распространении</A>
  <LI><P><A href="#index_html_book">Книга по CGI.pm</A>
  <LI><P><A href="#index_html_y2000">CGI.pm и проблема 2000&nbsp;года</A>
  <LI><P><A href="#index_html_bugs">Отчеты об ошибках и поддержка</A>
  <LI><P><A href="#index_html_new">Что нового?</A>
</MENU>
<HR>
<H2><A name="index_html_installation">Загрузка и установка</A></H2>
<UL>
  <LI><P><STRONG><A href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.tar.gz">Загрузка архива gzip tar (для Unix)</A></STRONG>
  <LI><P><STRONG><A href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.zip">Загрузка архива pkzip (для Windows)</A></STRONG>
  <LI><P><STRONG><A href="http://stein.cshl.org/WWW/software/CGI/CGI.pm.sit">Загрузка архива sit (для Macintosh)</A></STRONG>
  <LI><P><STRONG><A href="http://stein.cshl.org/WWW/software/CGI/CGI.pm">Загрузка только модуля CGI (несжатого)</A></STRONG>
</UL>
<P>Текущая версия программного обеспечения может быть всегда загружена с копии владельца этого документа, поддерживаемой на <A href="http://stein.cshl.org/WWW/software/CGI/">http://stein.cshl.org/WWW/software/CGI/</A>.
<P>Этот пакет требует Perl&nbsp;5.004 или выше. Ранние версии Perl могут работать, но CGI.pm не тестировался с ними. Если вам действительно невтерпеж, отредактируйте исходный код, чтобы удалить строку, которая говорит "требуется&nbsp;5.004" ("require&nbsp;5.004"), но не удивляйтесь, если вы натолкнетесь на проблемы.
<P>Если вы используете систему Unix, вам следует сделать установку Perl для себя. Направляйтесь в каталог, содержащий CGI.pm, и наберите следующие команды:
<PRE>
  % perl Makefile.PL
  % make
  % make install
</PRE>
<P>Возможно, вам придется быть администратором (root), чтобы сделать следующий шаг.
<P>Это создаст два новых файла в вашей библиотеке Perl. <B>CGI.pm</B> - главный файл библиотеки. <B>Carp.pm</B> (в подкаталоге "CGI") содержит некоторые необязательные полезные подпрограммы для написания хорошо форматированных сообщений об ошибках в журналах (log) вашего сервера. Смотрите man-страницу Carp.pm более детально.
<P><STRONG>Если вы получаете сообщения об ошибках, когда вы пытаетесь устанавливать</STRONG>, тогда вы:
<OL>
  <LI><P>либо запускаете версию Perl для Windows&nbsp;NT или Macintosh, которая не имеет встроенной в него программы make или MakeMaker.
  <LI><P>либо имеете старую версию Perl. Обновите до 5.004 или выше.
</OL>
<P>В первом случае не паникуйте. Вот рецепт, который работает (команды даны в форме MS-DOS/Windows):
<PRE>
  &gt; cd CGI.pm-2.46
  &gt; copy CGI.pm C:\Perl\lib
  &gt; mkdir C:\Perl\lib\CGI
  &gt; copy CGI\*.pm C:\Perl\lib\CGI
</PRE>
<P>Измените этот рецепт, если ваша библиотека Perl имеет другое местонахождение.
<P>Для пользователей Macintosh просто перетащите файл, называющийся CGI.pm, в папку, где хранятся ваши другие файлы .pm для Perl. Также перетащите папку, называющуюся "CGI".
<P><STRONG>Если вы не имеете достаточных привилегий для установки в /usr/local/lib/perl5</STRONG>, вы все же можете использовать CGI.pm. Измените рецепт установки следующим образом:
<PRE>
  % perl Makefile.PL INSTALLDIRS=site INSTALLSITELIB=/home/your/private/dir
  % make
  % make install
</PRE>
<P>Замените <CITE>/home/your/private/dir</CITE> полным путем в каталог, в который вы хотите, чтобы библиотека была помещена. Теперь начинайте ваши скрипты CGI с преамбулы вроде следующей:
<PRE>
  use lib '/home/your/private/dir';
  use CGI;
</PRE>
<P>Не забудьте заменить /home/your/private/dir подлинным местонахождением CGI.pm.
<P><A href="#index_html_non_unix">Замечания об использовании CGI.pm на NT и других платформах не-Unix</A>
<HR>
<H2><A name="index_html_functionvsoo">Функционально-ориентированное использование в сравнении с объектно-ориентированным</A></H2>
<P>CGI.pm может использоваться в двух различных режимах, называемых <CITE>функционально-ориентированным</CITE> и <CITE>объектно-ориентированным</CITE>. В функционально-ориентированном режиме, вы сначала импортируете функции CGI в пространство имен вашего скрипта, затем непосредственно вызываете эти функции. Простенький функционально-ориентированный скрипт выглядит следующим образом:
<PRE>
  #!/usr/local/bin/perl
  use CGI qw/:standard/;

  print header(),
    start_html(-title=&gt;'Здорово!'),
    h1('Здорово!'),
    'Смотри, мам, нету рук!',
    end_html();
</PRE>
<P>Оператор <CITE>use</CITE> загружает определения CGI.pm и импортирует набор ":standard" определений функций. Потом мы делаем вызовы различных функций, таких как <CITE>header()</CITE>, чтобы сгенерировать заголовок HTTP, <CITE>start_html()</CITE>, чтобы воспроизвести верхнюю часть документа HTML, <CITE>h1()</CITE>, чтобы воспроизвести заголовок первого уровня и так далее.
<P>В дополнение к стандартному набору, существует много необязательных наборов менее часто использующихся функций CGI. Смотрите <A href="#index_html_import">импортирование методов CGI</A> за всеми подробностями.
<P>В объектно-ориентированном режиме, вы пишите <CITE>use CGI;</CITE> без указания каких-либо функций или наборов функций для импорта. В этом случае, вы связываетесь с CGI.pm через объект CGI. Этот объект создается вызовом <CITE>CGI::new()</CITE> и инкапсулирует (заключает в себе) всю информацию о состоянии текущей транзакции CGI, такую как значения параметров CGI, переданные вашему скрипту. Хотя и более многословен, этот стиль кодирования имеет преимущество, позволяющее вам создавать множество объектов CGI, сохранять их состояние на диск или в базу данных, а также манипулировать ими, чтобы достичь ловких эффектов.
<P>Тот же скрипт, написанный, используя объектно-ориентированный стиль, выглядит следующим образом:
<PRE>
  #!/usr/local/bin/perl
  use CGI;

  $q = new CGI;
  print $q-&gt;header(),
    $q-&gt;start_html(-title=&gt;'Здорово!'),
    $q-&gt;h1('Здорово!'),
    'Смотри, мам, нету рук!',
    $q-&gt;end_html();
</PRE>
<P>Объектно-ориентированный режим имеет также преимущество потребления несколько меньшего количества памяти, чем функционально-ориентированный стиль кодирования. Это может иметь значение для пользователей постоянных интерпретаторов Perl, таких как <A href="http://perl.apache.org/">mod_perl</A>.
<P>Большинство примеров кода показаны ниже в объектно-ориентированном стиле кодирования. Мысленно переводите их функционально-ориентированный стиль, если вы предпочитаете его.
<H2><A name="index_html_query">Создание нового объекта CGI</A></H2>
<P>Самое основное использование CGI.pm - добраться до параметров запроса, представленного вашему скрипту. Чтобы создать новый объект CGI, который содержит параметры переданные вашему скрипту, помещайте следующее наверху ваших программ CGI на Perl:
<PRE>
  use CGI;

  $query = new CGI;
</PRE>
<P>В объектно-ориентированном мире Perl&nbsp;5, этот код вызывает метод new() класса CGI и сохраняет новый объект CGI в переменной, названной $query. Метод new() делает всю грязную работу по грамматическому разбору параметров скрипта скрипта и переменных окружения и сохраняет свои результаты в новом объекте. Теперь вы будете делать вызовы методов, используя этот объект, чтобы добираться до параметров, генерировать элементы формы и делать другие полезные вещи.
<P>Альтернативная форма метода new() позволяет вам читать параметры скрипта из ранее открытого указателя файла:
<PRE>  $query = new CGI(FILEHANDLE)</PRE>
<P>Указатель файла может содержать URL-закодированную строку запроса или может быть рядом разделенных символами новой строки пар ЯРЛЫК=ЗНАЧЕНИЕ. Это совместимо с методом save(). Это позволяет вам сохранить состояние скрипта CGI в файл и перезагрузить его позднее. Также возможно сохранять содержимое нескольких объектов запросов в один и тот же файл, как внутри одиночного скрипта так и на период времени. Вы можете затем перезагрузить множество записей в массив объектов запросов чем-то вроде следующего:
<PRE>
  open (IN,"test.in") || die;
  while (!eof(IN)) {
    my $q = new CGI(IN);
    push(@queries,$q);
  }
</PRE>
<P>Вы можете делать простые базы данных таким образом или создать гостевую книгу. Если вы - пурист Perl, вы можете передавать ссылку на glob указателя файла вместо имени указателя файла. Это "официальный" способ передавать указатели файлов в Perl&nbsp;5:
<PRE>  my $q = new CGI(\*IN);</PRE>
<P>(Если вы не знаете, о чем я говорю, тогда вы - не пурист Perl, и вам не нужно беспокоиться об этом.)
<P>Если вы используете функционально-ориентированный интерфейс и вы хотите инициировать состояние CGI из указателя файла, способ сделать это - использование <CITE>restore_parameters()</CITE>. Он будет (пере)инициировать объект CGI по умолчанию из обозначенного указателя файла.
<PRE>
  open (IN,"test.in") || die;
  restore_parameters(IN);
  close IN;
</PRE>
<P>Вы можете инициировать объект CGI из ссылки на ассоциативный массив. Значения могут быть как одно- так  и многозначными:
<PRE>
  $query = new CGI({'динозавр'=&gt;'барни','песня'=&gt;'Я люблю тебя',
                    'друзья'=&gt;[qw/Джессика Джордж Нэнси/]});
</PRE>
<P>Вы можете инициировать объект CGI, передавая строку запроса в стиле URL в метод new(), как здесь:
<PRE>  $query = new CGI('динозавр=барни&amp;цвет=фиолетовый');</PRE>
<P>Или вы можете клонировать объект CGI из существующего. Список параметров клона будет идентичным, но другие поля, такие как autoescaping - нет:
<PRE>
  $old_query = new CGI;
  $new_query = new CGI($old_query);
</PRE>
<P>Эта форма также позволяет вам создавать объект CGI, который изначально пуст:
<PRE>  $empty_query = new CGI('');</PRE>
<P>Смотрите <A href="#index_html_advanced">продвинутые приемы</A> за большей информацией.
<H3><A name="index_html_keywords">Вызов списка ключевых слов из запроса</A></H3>
<PRE>  @keywords = $query-&gt;keywords</PRE>
<P>Если скрипт был вызван, как результат поиска &lt;ISINDEX&gt;, синтаксически разобранные ключевые слова могут быть получены методом keywords(). Этот метод вернет ключевые слова, как массив Perl.
<H3><A name="index_html_parameters">Вызов имен всех параметров, переданных в ваш скрипт</A></H3>
<PRE>  @names = $query-&gt;param</PRE>
<P>Если скрипт был вызван со списком параметров (например, "имя1=значение1&amp;имя2=значение2&amp;имя3=значение3"), метод param() вернет имена параметров, как список. Для обратной совместимости этот метод будет работать, даже если скрипт был вызван, как скрипт &lt;ISINDEX&gt;: в этом случае будет возвращен одиночный параметр, названный 'keywords'.
<H3><A name="index_html_values">Вызов значения(ий) именованного параметра</A></H3>
<PRE>
  @values = $query-&gt;param('фу');
    -или-
  $value  = $query-&gt;param('фу');
</PRE>
<P>Передайте методу param() один аргумент, чтобы вызвать значение именованного параметра. Если параметр многозначен (например, из множества выбора в списке с возможностью прокрутки), вы можете запросить на получение массива. Иначе метод вернет одно значение.
<P>Как и для версии 1.50 этой библиотеки, возвращаемый массив имен параметров будет в том же порядке, в котором браузер послал их. Хотя это и не гарантирует идентичность порядку, в котором параметры были определены в заполняемой форме, обычно это так.
<H3><A name="index_html_setting">Установка значения(ий) именованного параметра</A></H3>
<PRE>
  $query-&gt;param('фу','один','массив','значений');
    -или-
  $query-&gt;param(-name=&gt;'фу',-values=&gt;['один','массив','значений']);
</PRE>
<P>Это устанавливает значение для именованного параметра 'фу' в одно или более значений. Эти значения будут использоваться для инициации элементов формы, если вы так пожелаете. Заметьте, что это единственный способ насильственно изменить значение поля формы после его предыдущей установки.
<P>Второй пример показывает альтернативный стиль вызова функции "с именованными параметрами", который принят многими методами CGI. Смотрите <A href="#index_html_named_param">вызов функций CGI, которые принимают множество аргументов</A> для объяснения этого стиля.
<H3><A name="index_html_append">Присоединение параметра</A></H3>
<PRE>  $query-&gt;append(-name=&gt;'фу',-values=&gt;['еще','больше','значений']);</PRE>
<P>Это добавляет значение или список значений к именованному параметру. Значения присоединяются к концу параметра, если он уже существует. Иначе параметр создается.
<H3><A name="index_html_deleting">Удаление именованного параметра совсем</A></H3>
<PRE>  $query-&gt;delete('фу');</PRE>
<P>Это удаляет именованный параметр совсем. Это полезно, когда вы хотите переустановить значение параметра, так чтобы он не передавался дальше между вызовами скрипта.
<H3><A name="index_html_deleting_all">Удаление всех параметров</A></H3>
<PRE>  $query-&gt;delete_all();</PRE>
<P>Это удаляет все параметры и оставляет вас с пустым объектом CGI. Это может быть полезно, чтобы восстановить все установки по умолчанию, произведенные методами, генерирующими элементы формы.
<H3><A name="index_html_importing">Импортирование параметров в пространство имен</A></H3>
<PRE>
  $query-&gt;import_names('R');
  print "Ваше имя - $R::name\n"
  print "Ваши любимые цвета: @R::colors\n";
</PRE>
<P>Это импортирует все параметры в заданное пространство имен. Например, если были параметры, названные 'foo1', 'foo2' и 'foo3', после исполнения <CODE>$query-&gt;import_names('R')</CODE>, переменные <CODE>@R::foo1, $R::foo1, @R::foo2, $R::foo2,</CODE> и тому подобные удобно появятся среди существующих. Так как CGI не имеет пути узнать, ожидаете ли вы много- или однозначный параметр, он создает две переменных для каждого параметра. Одна, массив, содержит все значения, а другая - скаляр, содержащий первый член массива. Используйте ту, которая уместна. Для списков ключевых слов (a+b+c+d), будет создана переменная @R::keywords.
<P>Если вы не указываете пространство имен, этот метод предполагает пространство имен "Q".
<P>Необязательный второй аргумент <B>import_names</B>, если он присутствует и ненулевой, удалит содержимое пространства имен перед загрузкой в него. Это может быть полезно для окружений, таких как mod_perl, из которых скрипт не выходит после обработки запроса.
<P><STRONG>Предупреждение</STRONG>: не импортируйте в пространство имен 'main'. Это представляет крупный риск безопасности, так как злые люди могут тогда использовать эту особенность для переопределения центральных переменных, таких как @INC. CGI.pm выйдет с ошибкой, если вы попытаетесь сделать это.
<H3><A name="index_html_param_fetch">Прямой доступ к списку параметров</A></H3>
<PRE>
  $q-&gt;param_fetch('адрес')-&gt;[1] = 'переулок Пересмешника, 1313';
  unshift @{$q-&gt;param_fetch(-name=&gt;'адрес')},'Джордж Манстер';
</PRE>
<P>Если you need access to the parameter list in a way that isn't covered by the methods above, вы можете obtain a direct reference to it by calling the <B>param_fetch()</B> method with the name of the parameter you want. This will return an array reference to the named parameters, which you then can manipulate in any way you like.
<P>Вы можете call <B>param_fetch()</B> with the name of the CGI parameter, or with the <B>-name</B> argument, which has the same meaning as elsewhere.
<H3>Fetching the Parameter List as a Hash</H3>
<PRE>
  $params = $q-&gt;Vars;
  print $params-&gt;{'адрес'};
  @foo = split("\0",$params-&gt;{'фу'});
  %params = $q-&gt;Vars;

  use CGI ':cgi-lib';
  $params = Vars;
</PRE>
<P>Many people want to fetch the entire parameter list as a hash in which the keys are the names of the CGI parameters, and the values are the parameters' values. The <B>Vars()</B> method does this. Called in a scalar context, it возвращает the parameter list as a tied hash reference. Changing a key changes the value of the parameter in the underlying CGI parameter list. Called in an array context, it возвращает the parameter list as an ordinary hash. This allows you to read the contents of the parameter list, but not to change it.
<P>When using this, the thing you must watch out for are multivalued CGI parameters. Because a hash cannot distinguish between scalar and array context, multivalued parameters will be returned as a packed string, separated by the "\0" (null) character. You must split this packed string чтобы get at the individual values. This is the convention introduced long ago by Steve Brenner in his cgi-lib.pl module for Perl version 4.
<P>Если вы желаете использовать <B>Vars()</B>, как функцию, импортируйте набор вызовов функций <I>:cgi-lib</I> (смотрите также раздел про <A href="#index_html_migrating">совместимость с CGI-LIB</A>).
<H3><A name="index_html_errors">Возвращение ошибок CGI</A></H3>
<P>Ошибки can occur while processing user input, particularly when processing uploaded files. When these errors occur, CGI will stop processing and return an empty parameter list. Вы можете test for the existence and nature of errors using the <STRONG>cgi_error()</STRONG> function. The error messages are formatted as HTTP status codes. Вы можете either incorporate the error text into an HTML page, or use it as the value of the HTTP status:
<PRE>
  my $error = $q-&gt;cgi_error;
  if ($error) {
    print $q-&gt;header(-status=&gt;$error),
          $q-&gt;start_html('Проблемы'),
          $q-&gt;h2('Запрос не обработан'),
          $q-&gt;strong($error);
    exit 0;
  }
</PRE>
<P>Когда вы используете функционально-ориентированный интерфейс (смотрите следующий раздел), ошибки могут встречаться только, когда вы в первый раз вызываете <STRONG>param()</STRONG>. Будьте готовы к этому!
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_saving">Сохранение текущего состояния формы</A></H2>
<H3>Сохранение состояния в файл</H3>
<PRE>  $query-&gt;save(FILEHANDLE)</PRE>
<P>This writes the current query out to the file handle of your choice. The file handle must already be open and be writable, but other than that it can point to a file, a socket, a pipe, or whatever. The contents of the form are written out as TAG=VALUE pairs, which can be reloaded with the new() method at some later time. Вы можете write out multiple queries to the same file and later read them into query objects one by one.
<P>Если вы желаете использовать этот метод method from the function-oriented (non-OO) interface, the exported name for this method is <CITE>save_parameters()</CITE>. Смотрите <A href="#index_html_advanced">продвинутые приемы</A> за большей информацией.
<H3><A name="index_html_self_referencing">Сохранение состояния in a Self-Referencing URL</A></H3>
<PRE>  $my_url=$query-&gt;self_url</PRE>
<P>Этот вызов возвращает a URL that, when selected, reinvokes this script with all its state information intact. Это может быть полезно, когда вы хотите to jump around within a script-generated document using internal anchors, but don't want to disrupt the current contents of the form(s). Смотрите <A href="#index_html_advanced">продвинутые приемы</A> для примера.
<P>If you'd like to get the URL without the entire query string appended to it, use the <CODE>url()</CODE> method:
<PRE>  $my_self=$query-&gt;url</PRE>
<H3>Получение URL скрипта</H3>
<PRE>
  $full_url      = $query-&gt;url();
  $full_url      = $query-&gt;url(-full=&gt;1);   #альтернативный синтаксис
  $relative_url  = $query-&gt;url(-relative=&gt;1);
  $absolute_url  = $query-&gt;url(-absolute=&gt;1);
  $url_with_path = $query-&gt;url(-path_info=&gt;1);
  $url_with_path_and_query = $query-&gt;url(-path_info=&gt;1,-query=&gt;1);
</PRE>
<P><CODE>url()</CODE> возвращает URL скрипта в ряде форматов. Вызванный без каких-либо аргументов, он возвращает полную форму URL, включая имя хоста и номер порта
<PRE>  http://your.host.com/path/to/script.cgi</PRE>
Вы можете модифицировать этот формат следующими именованными аргументами:
<DL>
  <DT><P><STRONG>-absolute</STRONG>
  <DD><P>Если true, вырабатывает абсолютный URL, т.е.
  <PRE>  /path/to/script.cgi</PRE>
  <DT><P><STRONG>-relative</STRONG>
  <DD><P>Вырабатывает относительный URL. Он полезен, если вы хотите вызвать ваш скрипт заново с другими параметрами. Например:
  <PRE>  script.cgi</PRE>
  <DT><P><STRONG>-full</STRONG>
  <DD><P>Вырабатывает полный URL точно так же как, если бы он был вызван без каких-либо аргументов. Он перекрывает аргументы -relative и -absolute.
  <DT><P><STRONG>-path</STRONG>,<STRONG>-path_info</STRONG>
  <DD><P>Приклепляет дополнительную информацию о пути к URL. Он может комбинироваться с -full, -absolute или -relative. -path_info предусмотрен как синоним.
  <DT><P><STRONG>-query</STRONG> (<STRONG>-query_string</STRONG>)
  <DD><P>Приклепляет строку запроса к URL. Он может комбинироваться с -full, -absolute или -relative. -query_string предусмотрен как синоним.
</DL>
<H3>Смешивание параметров POST и URL</H3>
<PRE>  $color = $query-&gt;url_param('цвет');</PRE>
<P>It is possible for a script to receive CGI parameters in the URL as well as in the fill-out form by creating a form that POSTs to a URL containing a query string (a "?" mark followed by arguments). Метод <B>param()</B> всегда будет будет возвращать содержимое POST заполняемой формы, игнорируя строку запроса URL. Чтобы вернуть параметры URL, вызывайте метод <B>url_param()</B>. Используйте его тем же способом, что и <B>param()</B>. Главное отличие в том, что он позволяет вам читать параметры, но не установливать их.
<P>Under no circumstances will the contents of the URL query string interfere with similarly-named CGI parameters in POSTed forms. Если вы попытаетесь смешать строку запроса URL с a form submitted методом GET, результаты не будут теми, которые вы ожидаете.
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H3><A name="index_html_named_param">Вызов функций CGI, которые принимают множество аргументов</A></H3>
<P>In versions of CGI.pm prior to 2.0, it could get difficult to remember the proper order of arguments in CGI function calls that accepted five or six different arguments. As of 2.0, there's a better way to pass arguments to the various CGI functions. In this style, you pass a series of name=&gt;argument pairs, like this:
<PRE>
  $field = $query-&gt;radio_group(-name=&gt;'OS',
                               -values=&gt;[Unix,Windows,Macintosh],
                               -default=&gt;'Unix');
</PRE>
<P>The advantages of this style are that you don't have to remember the exact order of the arguments, and if you leave out a parameter, it will usually default to some reasonable value. If you provide a parameter that the method doesn't recognize, it will usually do something useful with it, such as incorporating it into the HTML tag as an attribute. Например if Netscape decides next week to add a new JUSTIFICATION parameter to the text field tags, вы можете start using the feature without waiting for a new version of CGI.pm:
<PRE>
  $field = $query-&gt;textfield(-name=&gt;'State',
                             -default=&gt;'gaseous',
                             -justification=&gt;'RIGHT');
</PRE>
<P>This will result in an HTML tag that looks like this:
<PRE>
  &lt;INPUT type="text" name="State" value="gaseous"
  justification="RIGHT"&gt;
</PRE>
<P>Parameter names are case insensitive: вы можете использовать -name, or -Name or -NAME. You don't have to use the hyphen if you don't want to. After creating a CGI object, call the <STRONG><CODE>use_named_parameters()</CODE></STRONG> method with a nonzero value. This will tell CGI.pm that you intend to use named parameters exclusively:
<PRE>
  $query = new CGI;
  $query-&gt;use_named_parameters(1);
  $field = $query-&gt;radio_group('name'=&gt;'OS',
                               'values'=&gt;['Unix','Windows','Macintosh'],
                               'default'=&gt;'Unix');
</PRE>
<P>Actually, CGI.pm only looks for a hyphen in the first parameter. So вы можете leave it off subsequent parameters if you like. Something to be wary of is the potential that a string constant like "values" will collide with a keyword (and in fact it does!) While Perl usually figures out when you're referring to a function and when you're referring to a string, you probably should put quotation marks around all string constants just to play it safe.
<P>Параметры HTML/HTTP, которые содержат внутренние дефисы, такие как <I>-Content-language</I> могут быть passed by putting quotes around them, or by using an underscore for the second hyphen, например <CITE>-Content_language</CITE>.
<P>The fact that you must use curly {} braces around the attributes passed to functions that create simple HTML tags but don't use them around the arguments passed to all other functions has many people, including myself, confused. As of 2.37b7, the syntax is extended to allow you to use curly braces for all function calls:
<PRE>
  $field = $query-&gt;radio_group({-name=&gt;'OS',
                                -values=&gt;[Unix,Windows,Macintosh],
                                -default=&gt;'Unix'});
</PRE>
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_header">Создание заголовка HTTP</A></H2>
<H3><A name="index_html_standard_header">Создание стандартного заголовка для виртуального документа</A></H3>
<PRE>  print $query-&gt;header('image/gif');</PRE>
<P>Это распечатывает необходимый HTTP Content-type: заголовок и строку бланка реквизита под ним. Если не определен параметр, он по умолчанию 'text/html'.
<P>Расширенная форма этого метода позволяет вам определять код состояния и сообщение, передаваемые назад в браузер:
<PRE>
  print $query-&gt;header(-type=&gt;'image/gif',
                       -status=&gt;'204 No Response');
</PRE>
<P>Это предоставляет браузеру код состояния 204 (Нет ответа). Подобающе ведущие себя браузеры не предпринимают никаких действий, просто остаются на текущей странице. (Это предназначено для скрипта, который делает некоторую обработку, но не нуждается в представлении каких-либо результатов, или для скрипта, вызванного, когда пользователь щелкнул на пустой части активной карты изображения (clickable image map).)
<P>Распознаются несколько других именованных параметров. Здесь искусственный пример, который использует их все:
<PRE>
  print $query-&gt;header(-type=&gt;'image/gif',
                       -status=&gt;'402 Payment Required',
                       -expires=&gt;'+3d',
                       -cookie=&gt;$my_cookie,
                       -Cost=&gt;'$0.02');
</PRE>
<H4>-expires</H4>
<P>Некоторые браузеры, такие как Internet Explorer, кэшируют выходную информацию скриптов CGI. Другие, такие как Netscape Navigator, - нет. Это ведет к раздражению и несовместимому поведению, когда переходишь от одного браузера к другому. Вы можете заставить поведение быть совместимым, используя параметр <STRONG>-expires</STRONG>. Когда вы определяете абсолютный или относительный интервал истечения этим параметром, браузеры и прокси-серверы будут кэшировать выходную информацию скрипта до указанного срока истечения. Все следующие формы действительны для поля <STRONG>-expires</STRONG>:
<PRE>
  +30s                              30 секунд с настоящего момента
  +10m                              десять минут с настоящего момента
  +1h                               один час с настоящего момента
  -1d                               вчера (т.е. "ASAP!")
  now                               немедленно
  +3M                               через три месяца
  +10y                              через срок в десять лет
  Thu, 25-Apr-1999 00:40:33 GMT     в указанное время и дату
</PRE>
<P>Когда вы используете <STRONG>-expires</STRONG>, скрипт также генерирует корректный штамп времени для сгенерированного документа, чтобы убедиться в том, что ваши часы и часы браузера согласованы. Это позволяет вам создавать документы, которые надежно кэшируются на короткие периоды времени.
<P><STRONG>CGI::expires()</STRONG> - статический вызов функции, используемой для внутренних нужд, которая обращает относительные временные интервалы в даты HTTP. Вы можете вызывать ее непосредственно, если желаете.
<H4>-cookie</H4>
<P>Параметр <STRONG>-cookie</STRONG> генерирует заголовок, который говорит браузерам Netscape возвращать "magic cookie" в течение всех последующих транзакций с вашим скриптом. HTTP cookies имеют специальный формат, который включает интересные атрибуты, такие как срок истечения. Используйте метод <A href="#index_html_cookies">cookie()</A>, чтобы создавать и возвращать cookies сессии. Значение этого параметра может быть или скалярным значением или ссылкой на массив. Вы можете использовать последний, чтобы генерировать множество cookies. (Вы можете использовать псевдоним <STRONG>-cookies</STRONG> для читабельности.)
<H4>-nph</H4>
<P>Параметр <STRONG>-nph</STRONG>, если он установлен в ненулевое значение, будет генерировать заголовок действительный заголовок для использования в скриптах с заголовками, не подлежащими грамматическому разбору. Например:
<PRE>
  print $query-&gt;header(-nph=&gt;1,
                       -status=&gt;'200 OK',
                       -type=&gt;'text/html');
</PRE>
<P>Вам понадобится использовать это, если:
<OL>
  <LI><P>Вы используете Microsoft Internet Information Server.
  <LI><P>Вам нужно создать небуферизированный вывод, например, для использования в скрипте "server push".
  <LI><P>Вам нужно воспользоваться расширениями HTTP, не поддерживаемыми вашим сервером.
</OL>
<P>Смотрите <A href="#index_html_nph">использование скриптов NPH</A> за большей информацией.
<H4>Другие поля заголовка</H4>
<P>Некоторые другие параметры, которые вы передаете в <STRONG>header()</STRONG>, обращаются в корректно отформатированные поля заголовка HTTP, даже если они не вызываются для текущей спецификации HTTP. Например, образец, который появился несколькими абзацами выше, создает поле, которое похоже на следующее:
<PRE>  Cost: $0.02</PRE>
<P>Вы можете использовать его, чтобы воспользоваться новыми полями заголовка HTTP, не дожидаясь следующего выпуска CGI.pm.
<H3><A name="index_html_redirect">Создание заголовка для запроса переадресации</A></H3>
<PRE>  print $query-&gt;redirect('http://somewhere.else/in/the/world');</PRE>
<P>Это генерирует запрос переадресации для удаленного браузера. Он немедленно перейдет на указанный URL. Вам следует выйти вскоре после этого. Больше ничего не будет демонстрироваться.
<P>Вы можете добавить ваши собственные заголовки к этому, как и в методе header().
<P>Вам следует всегда использовать абсолютные или полные URL в запросах переадресации. Относительные URL <STRONG>не</STRONG> будут работать корректно.
<P>Альтернативный синтаксис для <CODE>redirect()</CODE> таков:
<PRE>
  print $query-&gt;redirect(-location=&gt;'http://somewhere.else/',
                         -nph=&gt;1);
</PRE>
<P>Параметр <STRONG>-location</STRONG> дает URL места назначения. Вы можете также использовать <STRONG>-uri</STRONG> или <STRONG>-url</STRONG>, если предпочитаете.
<P>Параметр <STRONG>-nph</STRONG>, если он ненулевой, говорит CGI.pm, что этот скрипт запущен, как скрипт с заголовком, не подлежащим грамматическому разбору. Смотрите <A href="#index_html_nph">использование скриптов NPH</A> за большей информацией.
<P>Параметр <STRONG>-method</STRONG> говорит браузеру, какой метод использовать для переадресации. Это удобно, если, например, ваш скрипт был вызван из операции POST заполняемой формы, а вы хотите переадресовать браузер на статическую страницу, которая требует GET.
<P>Все другие параметры, распознаваемые методом <TT>header()</TT>, также справедливы в <TT>redirect</TT>.
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_html">Ярлыки HTML</A></H2>
<H3>Создание заголовка HTML</H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;start_html(-title=&gt;'Секреты пирамид',
                           -author=&gt;'fred@capricorn.org',
                           -base=&gt;'true',
                           -meta=&gt;{'keywords'=&gt;'фараон секрет мумия',
                                   'copyright'=&gt;'авторские права 1996 King Tut'},
                           -style=&gt;{'src'=&gt;'/styles/style1.css'},
                           -dtd=&gt;1,
                           -BGCOLOR=&gt;'blue');

  <EM></EM>
  print $query-&gt;start_html('Секреты пирамид','fred@capricorn.org','true');
</PRE>
<P>Это вернет закрытый заголовок HTML и открывающий тег &lt;BODY&gt;. Все параметры необязательные:
<UL>
  <LI><P>Название документа (<STRONG>-title</STRONG>)
  <LI><P>Адрес электронной почты автора создаст тег &lt;LINK REV="MADE"&gt;, если присутствует (<STRONG>-author</STRONG>)
  <LI><P>Флаг истинности, если вы хотите включить тег &lt;BASE&gt; в заголовок (<STRONG>-base</STRONG>). Он поможет разрешить относительные адреса с абсолютными, когда документ перемещен, но сделает иерархию документов непортативной. Используйте с осторожностью!
  <LI><P>Параметр <STRONG>-xbase</STRONG>, если вы хотите включить тег &lt;BASE&gt;, который указывает некоторое внешнее расположение. Пример:
  <PRE>
  print $query-&gt;start_html(-title=&gt;'Секреты пирамид',
                           -xbase=&gt;'http://www.nile.eg/pyramid.html');
  </PRE>
  <LI><P>Параметр <STRONG>-target</STRONG>, если вы хотите иметь все ссылки и заполняемые формы на странице при переходе к другому кадру (frame). Пример:
  <PRE>
  print $query-&gt;start_html(-title=&gt;'Секреты пирамид',
                           -target=&gt;'answer_frame');
  </PRE>
  <P><STRONG>-target</STRONG> может быть использован или с <STRONG>-xbase</STRONG> или с <STRONG>-base</STRONG>.
  <LI><P>Параметр <STRONG>-meta</STRONG> используется, чтобы определить один или более тегов &lt;META&gt;. Передавайте этому параметру ссылку на ассоциативный массив, содержащий пары ключ/значение. Каждая пара становится тегом &lt;META&gt; в формате похожем на этот.
  <PRE>
  &lt;META name="keywords" content="фараон секрет мумия"&gt;
  &lt;META name="description" content="авторские права 1996 King Tut"&gt;
  </PRE>
  <P>Поддержки типа HTTP-EQUIV для тега &lt;META&gt; нет. Это потому что вы можете изменять заголовок HTTP непосредственно методом <A href="#index_html_header">header</A>. Пример:
  <PRE>
  print $q-&gt;header(-Refresh=&gt;'10; URL=http://www.capricorn.com');
  </PRE>
  <LI><P>Параметр <STRONG>-dtd</STRONG> используется, чтобы заставить start_html() генерировать для данного документа определение типа документа SGML. Оно используется редакторами SGML и издательскими системами Web класса high-end, чтобы определить тип документа. Однако, оно нарушает работу некоторых браузеров, в частности AOL. Значение этого параметра может быть одним из следующих:
  <OL>
    <LI><P>действительный DTD (смотрите <A href="http://ugweb.cs.ualberta.ca/~gerald/validate/lib/catalog">http://ugweb.cs.ualberta.ca/~gerald/validate/lib/catalog</A> для списка). Пример:
    <PRE>  -dtd=&gt;'-//W3C//DTD HTML&nbsp;3.2//EN'</PRE>
    <LI><P>значение истинности, которое не начинается с "-//", в этом случае вы получите стандартный DTD по умолчанию (справедливо для HTML&nbsp;2.0).
  </OL>
  <P>Вы можете изменить DTD по умолчанию, вызвав <STRONG>default_dtd()</STRONG> с предпочитаемым значением.
  <LI><P>Параметр <STRONG>-style</STRONG> используется, чтобы определить каскадную таблицу стилей. Больше информации по этому вопросу может быть найдено в <A href="#index_html_stylesheets">ограниченной поддержке каскадных таблиц стилей</A>
  <LI><P>Параметр <STRONG>-head</STRONG> используется, чтобы определить произвольные элементы радела &lt;HEAD&gt;. Например:
  <PRE>
  print header(-head=&gt;Link({-rel=&gt;'next',-href=&gt;'http://www.capricorn.com/s2.html'}));
  </PRE>
  <P>или даже
  <PRE>
  print header(-head=&gt;[Link({-rel=&gt;'next',-href=&gt;'http://www.capricorn.com/s2.html'}),
                       Link({-rel=&gt;'previous',-href=&gt;'http://www.capricorn.com/s1.html'})]);
  </PRE>
  <LI><P>Параметр <STRONG>-script</STRONG> используется, чтобы определить функции Netscape <A href="#index_html_javascripting">JavaScript</A>, чтобы включить их в страницу HTML. Это предпочтительный способ, чтобы библиотеку функций JavaScript, которые будут вызываться откуда-нибудь изнутри страницы. CGI.pm будет пытаться форматировать код JavaScript тем же способом, каким браузеры не-Netscape не хотят пытаться демонстрировать код JavaScript. К сожалению некоторые браузеры тем не менее путаются. Вот пример того, как создать библиотеку JavaScript и включить ее внутрь кода заголовка HTML:
  <PRE>
  $query = new CGI;
  print $query-&gt;header;

  $JSCRIPT=&lt;&lt;END;
  // Задать глупый вопрос
  function riddle_me_this() {
    var r = prompt("Кто ходит на четырех ногах утром, " +
                   "на двух ногах днем, и на трех ногах вечером?");
    response(r);
  }
  // Получить глупый ответ
  function response(answer) {
    if(answer == "человек") alert("Вы правы!");
    else alert("Неверно! Угадывайте заново.");
  }
  END
      
  print $query-&gt;start_html(-title=&gt;'Загадка Сфинкса',
                           -script=&gt;$JSCRIPT);
  </PRE>
  <P>Netscape&nbsp;3.0 и выше позволяет вам помещать код JavaScript во внешний документ и ссылаться на него по URL. Это позволяет вам хранить код JavaScript в файле или скрипте CGI , чтобы не загромождать каждую страницу исходным кодом. Netscape&nbsp;3.X-4.X и Internet Explorer&nbsp;3.X-4.X также распознают параметр "language", который позволяет вам использовать другие языки, такие как VBScript и PerlScript (ну да!) Чтобы использовать эти атрибуты передайте в параметр <STRONG>-script</STRONG> ссылку на хеш, содержащий один или более ключей <STRONG>language</STRONG>, <STRONG>src</STRONG> или <STRONG>code</STRONG>. Вот, как сослаться на URL внешнего скрипта:
  <PRE>
  print $q-&gt;start_html(-title=&gt;'Загадка Сфинкса',
                       -script=&gt;{-language=&gt;'JavaScript',-src=&gt;'/javascript/sphinx.js'});
  </PRE>
  <P>Вот как сослаться на код скрипта, включенного непосредственно в страницу:
  <PRE>
  print $q-&gt;start_html(-title=&gt;'Загадка Сфинкса',
                       -script=&gt;{-language=&gt;'PerlScript',-code-&gt;'print "Привет, мир!\n;"');
  </PRE>
  <P>Последняя особенность позволяет вам включать множество разделов &lt;SCRIPT&gt; в заголовок. Просто передайте список разделов скриптов, как ссылку на массив. Это позволяет вам определять различные исходные файлы для разных диалектов JavaScript. Пример:
  <PRE>
  print $q-&gt;start_html(-title=&gt;'Загадка Сфинкса',                      
                       -script=&gt;[{-language=&gt;'JavaScript1.0',
                                  -src=&gt;/javascript/utilities10.js'},
                                    {-language=&gt;'JavaScript1.1',
                                  -src=&gt;'/javascript/utilities11.js'},
                                    {-language=&gt;'JavaScript1.2',
                                  -src=&gt;'/javascript/utilities12.js'},
                                    {-language =&gt;'JavaScript28.2',
                                  -src=&gt;'/javascript/utilities219.js'}]);
  </PRE>
  <P>(Если это выглядит чуть-чуть экстравагантно, воспользуйтесь моим советом и не отделывайтесь от чистого написания скриптов CGI.)
  <LI><P>Параметр <STRONG>-noScript</STRONG> используется, чтобы передавать некоторый HTML, который будет демонстрироваться в браузерах, которые не имеют JavaScript (или имеют отключенный JavaScript).
  <LI><P>Параметры <STRONG>-onLoad</STRONG> и <STRONG>-onUnload</STRONG> используются, чтобы зарегистрировать обработчики событий JavaScript, которые нужно исполнить, когда страница, сгенерированная скриптом, открыта и закрыта соответственно. Пример:
  <PRE>
  print $query-&gt;start_html(-title=&gt;'Загадка Сфинкса',
                           -script=&gt;$JSCRIPT,
                           -onLoad=&gt;'riddle_me_this()');
  </PRE>
  <P>Смотрите <A href="#index_html_javascripting">JavaScripting</A> за большими подробностями.
  <LI><P>Любые дополнительные атрибуты, которые вы хотите включить в тег &lt;BODY&gt; (сколько вам нравится). Это хороший способ включать другие расширения Netscape, такие как цвет фона и образец обоев. (Пример выше устанавливает фон страницы в трепетно синий.) Вы можете использовать эту особенность, чтобы воспользоваться новыми особенностями HTML, не дожидаясь выпуска CGI.pm.
</UL>
<H3>Окончание документа HTML</H3>
<PRE>  print $query-&gt;end_html</PRE>
<P>Это оканчивает документ HTML печатью тегов &lt;/BODY&gt; &lt;/HTML&gt;.
<H3>Другие теги HTML</H3>
<P>CGI.pm provides shortcut methods for many other HTML tags. All HTML&nbsp;2 tags and the Netscape extensions are supported, as well as the HTML&nbsp;3 tags that are in common usage (including tables). Unpaired tags, paired tags, and tags that contain attributes are all supported using a simple syntax.
<P>To see the list of HTML tags that are supported, open up the CGI.pm file and look at the functions defined in the %EXPORT_TAGS array.
<H4>Непарные теги</H4>
<P>Unpaired tags include &lt;P&gt;, &lt;HR&gt; and &lt;BR&gt;. The syntax for creating them is:
<PRE>  print $query-&gt;hr;</PRE>
<P>This prints out the text "&lt;hr&gt;".
<H4>Парные теги</H4>
<P>Paired tags include &lt;EM&gt;, &lt;I&gt; and the like. The syntax for creating them is:
<PRE>  print $query-&gt;em("What a silly art exhibit!");</PRE>
<P>This prints out the text "&lt;em&gt;What a silly art exhibit!&lt;/em&gt;".
<P>Вы можете pass as many text arguments as you like: they'll be concatenated together with spaces. This allows you to create nested tags easily:
<PRE>  print $query-&gt;h3("The",$query-&gt;em("silly"),"art exhibit");</PRE>
<P>This создает the text:
<PRE>  &lt;h3&gt;The &lt;em&gt;silly&lt;/em&gt; art exhibit&lt;/h3&gt;</PRE>
<P>When used in conjunction with the <A href="#index_html_import">import</A> facility, the HTML shortcuts can make CGI scripts easier to read. Например:
<PRE>
  use CGI qw/:standard/;

  print h1("Road Guide"),
        ol(
          li(a({href=&gt;"start.html"},"The beginning")),
          li(a({href=&gt;"middle.html"},"The middle")),
          li(a({href=&gt;"end.html"},"The end"))
        );
</PRE>
<P>Most HTML tags are represented as lowercase function calls. There are a few exceptions:
<OL>
  <LI><P>The &lt;tr&gt; tag used to start a new table row conflicts with the Perl <CITE>translate</CITE> function <CODE>tr()</CODE>. Use TR() or Tr() instead.
  <LI><P>The &lt;param&gt; tag used to pass parameters to an applet conflicts with CGI's own <CODE>param() </CODE>method. Use PARAM() instead.
  <LI><P>The &lt;select&gt; tag used to create selection lists conflicts with Perl's select() function. Use <CODE>Select()</CODE> instead.
  <LI><P>The &lt;sub&gt; tag used to create subscripts conflicts wit Perl's operator for creating subroutines. Use <CODE>Sub()</CODE> instead.
</OL>
<H4>Теги с атрибутами</H4>
<P>To add attributes to an HTML tag, simply pass a reference to an associative array as the first argument. The keys and values of the associative array become the names and values of the attributes. Например, here's how to generate an &lt;A&gt; anchor link:
<PRE>
  use CGI qw/:standard/;

  print a({-href=&gt;"bad_art.html"},"Jump to the silly exhibit");

  <I>&lt;A HREF="bad_art.html"&gt;Jump to the silly exhibit&lt;/A&gt;</I>
</PRE>
<P>You may dispense with the dashes in front of the attribute names if you prefer:
<PRE>
  print img {src=&gt;'fred.gif',align=&gt;'LEFT'};

  <I>&lt;IMG ALIGN="LEFT" SRC="fred.gif"&gt;</I>
</PRE>
<P>Sometimes an HTML tag attribute has no argument. Например, ordered lists can be marked as COMPACT, or you желаете to specify that a table has a border with &lt;TABLE BORDER&gt;. The syntax for this is an argument that that points to an undef string:
<PRE>  print ol({compact=&gt;undef},li('one'),li('two'),li('three'));</PRE>
<P>Prior to CGI.pm version 2.41, providing an empty ('') string as an attribute argument was the same as providing undef. Однако, this has changed чтобы accomodate those who want to create tags of the form &lt;IMG ALT=""&gt;. The difference is shown in this table:
<TABLE border=1>
  <TBODY>
  <TR>
    <TH>CODE</TH>
    <TH>RESULT</TH></TR>
  <TR>
    <TD><TT>img({alt=&gt;undef})</TT></TD>
    <TD>&lt;IMG ALT&gt;</TD></TR>
  <TR>
    <TD><TT>img({alt=&gt;''})</TT></TD>
    <TD>&lt;IMT ALT=""&gt;</TD></TR></TBODY></TABLE>
<H4>Distributive HTML Tags and Tables</H4>
<P>All HTML tags are distributive. If you give them an argument consisting of a <B>reference</B> to a list, the tag will be distributed across each element of the list. Например, here's one way to make an ordered list:
<PRE>  print ul(li({-type=&gt;'disc'},['Sneezy','Doc','Sleepy','Happy']););</PRE>
<P>This example will result in HTML output that looks like this:
<PRE>
  &lt;UL&gt;
    &lt;LI TYPE="disc"&gt;Sneezy&lt;/LI&gt;
    &lt;LI TYPE="disc"&gt;Doc&lt;/LI&gt;
    &lt;LI TYPE="disc"&gt;Sleepy&lt;/LI&gt;
    &lt;LI TYPE="disc"&gt;Happy&lt;/LI&gt;
  &lt;/UL&gt;
</PRE>
<P>Вы можете take advantage of this to create HTML tables easily and naturally. Here is some code and the HTML it outputs:
<PRE>
  use CGI qw/:standard :html3 -no_debug/;

  print table({-border=&gt;undef},
        caption(strong('When Should You Eat Your Vegetables?')),
        Tr({-align=&gt;CENTER,-valign=&gt;TOP},
        [
           th(['','Breakfast','Lunch','Dinner']),
           th('Tomatoes').td(['no','yes','yes']),
           th('Broccoli').td(['no','no','yes']),
           th('Onions').td(['yes','yes','yes'])
        ]
      )
  );
</PRE>
<TABLE border=1>
  <CAPTION><STRONG>When Should You Eat Your Vegetables?</STRONG></CAPTION>
  <TBODY>
  <TR align=middle vAlign=top>
    <TH></TH>
    <TH>Breakfast</TH>
    <TH>Lunch</TH>
    <TH>Dinner</TH></TR>
  <TR align=middle vAlign=top>
    <TH>Tomatoes</TH>
    <TD>no</TD>
    <TD>yes</TD>
    <TD>yes</TD></TR>
  <TR align=middle vAlign=top>
    <TH>Broccoli</TH>
    <TD>no</TD>
    <TD>no</TD>
    <TD>yes</TD></TR>
  <TR align=middle vAlign=top>
    <TH>Onions</TH>
    <TD>yes</TD>
    <TD>yes</TD>
    <TD>yes</TD></TR></TBODY></TABLE>
<P>Notice the use of <B>-no_debug</B> in a program that we intend to call from the command line.
<P>If you want to produce tables programatically, вы можете do it this way:
<PRE>
  use CGI qw/:standard :html3 -no_debug/;

  @values = (1..5);
  @headings = ('N','N'.sup('2'),'N'.sup('3'));
  @rows = th(\@headings);
  foreach $n (@values) { push(@rows,td([$n,$n**2,$n**3])) }
  print table({-border=&gt;undef,-width=&gt;'25%'},
              caption(b('Wow.  I can multiply!')),
              Tr(\@rows)
             );
</PRE>
<TABLE border=1 width="25%">
  <CAPTION><B>Wow. I can multiply!</B></CAPTION>
  <TBODY>
  <TR>
    <TH>N</TH>
    <TH>N<SUP>2</SUP></TH>
    <TH>N<SUP>3</SUP></TH></TR>
  <TR>
    <TD>1</TD>
    <TD>1</TD>
    <TD>1</TD></TR>
  <TR>
    <TD>2</TD>
    <TD>4</TD>
    <TD>8</TD></TR>
  <TR>
    <TD>3</TD>
    <TD>9</TD>
    <TD>27</TD></TR>
  <TR>
    <TD>4</TD>
    <TD>16</TD>
    <TD>64</TD></TR>
  <TR>
    <TD>5</TD>
    <TD>25</TD>
    <TD>125</TD>
</TBODY></TABLE>
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_forms">Создание форм</A></H2>
<P><EM>Общее замечание 1.</EM> Все различные методы создания форм возвращают строки вызывающему. Эти строки будут содержать код HTML, который создаст запрашиваемый элемент формы. Вы несете ответственность собственно за распечатку этих строк. Она осуществляется таким образом, что вы можете помещать форматирующие теги вокруг элементов формы.
<P><A name="index_html_overriding"><EM>Общее замечание 2.</EM></A> Значения по умолчанию, которые вы определяете для форм используются только при <STRONG>первом</STRONG> вызове скрипта. Если значения уже присутствуют в строке запроса, то используются они, даже если они пусты.
<P>Если вы хотите изменить значение поля из его предыдущего значения, вы имеете два выбора:
<OL>
  <LI><P>вызвать метод <STRONG>param()</STRONG>, чтобы установить его.
  <LI><P>использовать параметр <B>-override</B> (псевдоним <B>-force</B>). (Это новая особенность в 2.15) Это заставит использовать значение по умолчанию, не считаясь с предыдущим значением поля:
  <PRE>  print $query-&gt;textfield(-name=&gt;'любимый_цвет',-default=&gt;'красный',-override=&gt;1);</PRE>
</OL>
<P>Если вы хотите переустановить все поля в их значения по умолчанию, вы можете:
<OL>
  <LI><P>Создать специальную кнопку <VAR>defaults</VAR>, используя метод <STRONG>defaults()</STRONG>.
  <LI><P>Создать гипертекстовую ссылку, которая вызывает ваш скрипт без каких-либо параметров.
</OL>
<P><EM>Общее замечание 3.</EM> Вы можете помещать множество форм на одну и ту же страницу, если желаете. Однако, учтите, что не всегда просто сохранять инфомацию о состоянии для более чем одной формы за раз. Смотрите <A href="#index_html_advanced">продвинутые приемы</A> за некоторыми советами.
<P><EM>Общее замечание 4.</EM> По популярному требованию, текст и метки, которые вы предусматриваете для элементов форм are escaped согласно правилам HTML. Это означает, что вы можете безопасно использовать "&lt;НАЖМИ МЕНЯ&gt;" как метку для кнопки. Однако, это поведение может вмешаться в вашу способность включать специальные последовательности символов HTML, такие как &amp;Aacute; (&Aacute;), в ваши поля. Если вы желаете выключить автоматический escaping, вызывайте метод <CODE>autoEscape()</CODE> со значением false непосредственно после создания объекта CGI:
<PRE>
  $query = new CGI;
  $query-&gt;autoEscape(undef);
</PRE>
<P>Вы можете обратно включить autoescaping в любое время вызовом <CODE>$query-&gt;autoEscape('да')</CODE>
<H3>Элементы формы</H3>
<MENU>
  <LI><P><A href="#index_html_startform">Opening a form</A>
  <LI><P><A href="#index_html_textfield">Поля ввода текста</A>
  <LI><P><A href="#index_html_textarea">Поля ввода большого текста</A>
  <LI><P><A href="#index_html_password">Поля пароля</A>
  <LI><P><A href="#index_html_upload">Поля выгрузки файлов</A>
  <LI><P><A href="#index_html_menu">Popup menus</A>
  <LI><P><A href="#index_html_scrolling_list">Cписки с возможностью прокрутки</A>
  <LI><P><A href="#index_html_checkbox_group">Группы выключателей</A>
  <LI><P><A href="#index_html_checkbox">Индивидуальные выключатели</A>
  <LI><P><A href="#index_html_radio">Группы переключателей</A>
  <LI><P><A href="#index_html_submit">Submission buttons</A>
  <LI><P><A href="#index_html_reset">Reset buttons</A>
  <LI><P><A href="#index_html_defaults">Reset to defaults button</A>
  <LI><P><A href="#index_html_hidden">Hidden fields</A>
  <LI><P><A href="#index_html_image">Clickable Images</A>
  <LI><P><A href="#index_html_button">Кнопки JavaScript</A>
  <LI><P><A href="#index_html_escape">Autoescaping HTML</A>
</MENU>
<P><A href="#index_html_contents">Наверх к содержанию</A>
<H3><A name="index_html_isindex">Создание тега ISINDEX</A></H3>
<PRE>  print $query-&gt;isindex($action);</PRE>
<P><STRONG>isindex()</STRONG> без каких-либо аргументов возвращает тег &lt;ISINDEX&gt;, который обозначает ваш скрипт, как URL для вызова. Если вы хотите, чтобы браузер вызвал другой URL для управления поиском, передайте isindex() URL, который вы хотите чтоб был вызван.
<H3><A name="index_html_startform">Starting And Ending A Form</A></H3>
<PRE>
  print $query-&gt;startform($method,$action,$encoding);
  <VAR>...различный материал формы...</VAR>
  print $query-&gt;endform;
</PRE>
<P><STRONG>startform()</STRONG> вернет тег &lt;FORM&gt; с необязательными методом, действием и form encoding, которые вы определяете. <STRONG>endform()</STRONG> возвращает тег &lt;/FORM&gt;.
<P>The form encoding supports the "file upload" feature of Netscape&nbsp;2.0 (и выше) и Internet Explorer&nbsp;4.0 (и выше). The form encoding tells the browser, как to package up the contents of the form чтобы transmit it across the Internet. Существует два типа of encoding, that вы можете определить:
<DL>
  <DT><P><STRONG>application/x-www-form-urlencoded</STRONG>
  <DD><P>This is the type of encoding used by all browsers prior to Netscape&nbsp;2.0. It is compatible with many CGI scripts and is suitable for short fields containing text data. For your convenience, CGI.pm stores the name of this encoding type in <CODE>$CGI::URL_ENCODED</CODE>.
  <DT><P><STRONG>multipart/form-data</STRONG>
  <DD><P>This is the newer type of encoding introduced by Netscape&nbsp;2.0. It is suitable for forms that contain very large fields or that are intended for transferring binary data. Most importantly, it enables the "file upload" feature of Netscape&nbsp;2.0 forms. For your convenience, CGI.pm stores the name of this encoding type in <CODE>CGI::MULTIPART()</CODE>
  <P>Формы, которые используют этот тип of encoding, are not easily interpreted by CGI scripts unless they use CGI.pm or another library that knows how to handle them. Unless you are using the file upload feature, there's no particular reason to use this type of encoding.
</DL>
<P>For compatability, the startform() method uses the older form of encoding by default. If you want to use the newer form of encoding By default, вы можете call <A href="#index_html_multipart">start_multipart_form()</A> instead of <CODE>startform()</CODE>.
<P>Если вы планируете использовать <A href="#index_html_javascripting">особенности JavaScript</A>, вы можете обеспечить <CODE>startform()</CODE> необязательными параметрами <CODE>-name</CODE> и/или <CODE>-onSubmit</CODE>. <CODE>-name</CODE> has no effect on the display of the form, but can be used to give the form an identifier so that it can be manipulated by JavaScript functions. Provide the <CODE>-onSubmit</CODE> parameter in order, чтобы зарегистрировать некоторый код JavaScript code to be performed just before the form is submitted. This is useful for checking the validity of a form before submitting it. Your JavaScript code should return a value of "true" to let Netscape know that it can go ahead and submit the form, and "false" to abort the submission.
<H3><A name="index_html_multipart">Starting a Form, которая использует особенность "выгрузки файла"</A></H3>
<PRE>
  print $query-&gt;start_multipart_form($method,$action,$encoding);
  <VAR>...различный материал формы...</VAR>
  print $query-&gt;endform;
</PRE>
<P>This has exactly the same usage as <CODE>startform()</CODE>, but it specifies form encoding type <CODE>multipart/form-data</CODE> as the default.
<H3><A name="index_html_textfield">Создание текстового поля</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;textfield(-name=&gt;'имя_поля',
                          -default=&gt;'начальное значение',
                          -size=&gt;50,-maxlength=&gt;80);

  <EM>Старый стиль</EM>
  print $query-&gt;textfield('фу','начальное значение',50,80);
</PRE>
<P><STRONG>textfield()</STRONG> вернет поле ввода текста.
<UL>
  <LI><P>Первый параметр (<STRONG>-name</STRONG>) - необходимое имя для поля.
  <LI><P>Необязательный второй параметр (<STRONG>-default</STRONG>) - начальное значение для содержимого поля.
  <LI><P>Необязательный третий параметр (<STRONG>-size</STRONG>) - размер поля в символах.
  <LI><P>Необязательный четвертый параметр (<STRONG>-maxlength</STRONG>) - максимальное число символов, которое поле вместит.
</UL>
<P>As with all these methods, the field will be initialized with its previous contents from earlier invocations of the script. Если вы хотите to force in the new value, overriding the existing one, смотрите <A href="#index_html_overriding">Общее замечание 2</A>.
<P>Когда форма обработана, значение текстового поля может быть возвращено вызовом:
<PRE>  $value = $query-&gt;param('фу');</PRE>
<P><STRONG>JavaScripting:</STRONG> Вы можете also provide <STRONG>-onChange, -onFocus, -onBlur, -onMouseOver, -onMouseOut</STRONG> and <STRONG>-onSelect</STRONG> parameters to register <A href="#index_html_javascripting">JavaScript</A> event handlers.
<H3><A name="index_html_textarea">Создание большого текстового поля</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;textarea(-name=&gt;'фу',-default=&gt;'начальное значение',
                         -rows=&gt;10,-columns=&gt;50);

  <EM>Старый стиль</EM>
 print $query-&gt;textarea('фу','начальное значение',10,50);
</PRE>
<P><STRONG>textarea()</STRONG> is just like textfield(), but it allows you to specify rows and columns for a multiline text entry box. Вы можете provide a начальное значение for the field, which can be long and contain multiple lines.
<P><STRONG>JavaScripting:</STRONG> Like textfield(), вы можете provide <STRONG>-onChange, -onFocus, -onBlur, -onMouseOver, -onMouseOut</STRONG> and <STRONG>-onSelect</STRONG> parameters to register <A href="#index_html_javascripting">JavaScript</A> event handlers.
<H3><A name="index_html_password">Создание поля пароля</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;password_field(-name=&gt;'секрет',-value=&gt;'начальное значение',
                               -size=&gt;50,-maxlength=&gt;80);

  <EM>Старый стиль</EM>
  print $query-&gt;password_field('секрет','начальное значение',50,80);
</PRE>
<P><STRONG>password_field()</STRONG> идентично textfield(), за исключением того, что его содержимое будет представляться звездочками на странице Web.
<H3><A name="index_html_upload">Создание поля выгрузки файла</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;filefield(-name=&gt;'выгруженный_файл',-default=&gt;'начальное значение',
                          -size=&gt;50,-maxlength=&gt;80);

  <EM>Старый стиль</EM>
  print $query-&gt;filefield('выгруженный_файл','начальное значение',50,80);
</PRE>
<P><STRONG>filefield()</STRONG> вернет поле формы, которое побудит пользователя выгрузить файл.
<UL>
  <LI><P>Первый параметр (<STRONG>-name</STRONG>) - обязательное имя для поля.
  <LI><P>Необязательный второй параметр (<STRONG>-default</STRONG>) - начальное значение для имени файла. Это поле в настоящее время игнорируется всеми браузерами, но всегда есть надежда!
  <LI><P>Необязательный третий параметр (<STRONG>-size</STRONG>) - размер поля в символах.
  <LI><P>Необязательный четвертый параметр (<STRONG>-maxlength</STRONG>) - максимальное число символов, которое поле вместит.
</UL>
<P>filefield() вернет поле выгрузки файла для использования в современных браузерах. Браузер побудит удаленного пользователя выбрать файл для передачи через Интернет на сервер. Другие браузеры в настоящее время игнорируют это поле.
<P>Чтобы полностью воспользоваться легкостью выгрузки файла, вы должны использовать новую <A href="#index_html_multipart">многодольную схему кодирования формы</A>. Вы можете сделать это или вызовом <A href="#index_html_startform">startform()</A> и определением типа кодирования <CODE>$CGI::MULTIPART</CODE>, или использованием нового метода <A href="#index_html_multipart">start_multipart_form()</A>. Если вы не используете многодольное кодирование, тогда вы сможете вернуть имя файла, выбранного пользователем, но вы не сможете получить доступ к его содержимому.
<P>Когда форма обработана, вы можете вернуть введенное имя файла, вызвав param().
<PRE>  $filename = $query-&gt;param('выгруженный_файл');</PRE>
<P>где "выгруженный_файл" - то, как вы назвали поле выгрузки файла. В зависимости от версии браузера имя файла, которое возвращено может быть полным локальным путем файла на машине <STRONG>удаленного пользователя</STRONG>, или только голым именем файла. Если путь предусмотрен, он следует обычаям путей локальной машины.
<P>Возвращенное имя файла - также указатель файла. Вы можете читать содержимое файла, используя стандартные для Perl вызовы чтения файла:
<PRE>
  # Прочитать текстовый файл и распечатать его
  while (&lt;$filename&gt;) { print }

  # Скопировать двоичный файл куда-нибудь в безопасное место
  open (OUTFILE,"&gt;&gt;/usr/local/web/users/feedback");
  while ($bytesread=read($filename,$buffer,1024)) { print OUTFILE $buffer }
  close $filename;
</PRE>
<P>There are problems with the dual nature of the upload fields. If you <CODE>use strict</CODE>, then Perl will complain when you try to use a string as a filehandle. Вы можете get around this by placing the file reading code in a block containing the <CODE>no strict</CODE> pragma. More seriously, it is possible for the remote user to type garbage into the upload field, in which case what you get from <B>param()</B> is not a filehandle at all, but a string.
<P>To be safe, use the <B>upload()</B> function (new in version 2.47). When called with the name of an upload field, <B>upload()</B> возвращает a filehandle, or undef if the parameter is not a valid filehandle.
<PRE>
  $fh = $query-&gt;upload('выгруженный_файл');
  while (&lt;$fh&gt;) { print; }
</PRE>
<P>This is the recommended idiom.
<P>Вы можете have several file upload fields in the same form, and even give them the same name if you like (in the latter case <CODE>param()</CODE> will return a list of file names). Однако, if the user attempts to upload several files with exactly the same name, CGI.pm will only return the last of them. This is a known bug.
<P>When processing an uploaded file, CGI.pm создает a temporary file on your hard disk and passes you a file handle to that file. After you are finished with the file handle, CGI.pm unlinks (deletes) the temporary file. If you need to вы можете access the temporary file directly. Its name is stored inside the CGI object's "private" data, and вы можете access it by passing the file name to the <A href="#index_html_tmpfilename">tmpFileName()</A> method:
<PRE>
  $filename = $query-&gt;param('выгруженный_файл');
  $tmpfilename = $query-&gt;tmpFileName($filename);
</PRE>
<P>The temporary file will be deleted automatically when your program exits unless you manually rename it. On some operating systems (such as Windows NT), you will need to close the temporary file's filehandle before your program exits. Otherwise the attempt to delete the temporary file will fail.
<P>A potential problem with the temporary file upload feature is that the temporary file is accessible to any local user on the system. In previous versions of this module, the temporary file was world readable, meaning that anyone could peak at what was being uploaded. As of version&nbsp;2.36, the modes on the temp file have been changed to read/write by owner only. Only the Web server and its CGI scripts can access the temp file. Unfortunately this means that one CGI script can spy on another! To make the temporary files <STRONG>really</STRONG> private, set the CGI global variable $CGI::PRIVATE_TEMPFILES to 1. Alternatively, call the built-in function CGI::private_tempfiles(1), or just <CITE>use CGI qw/-private_tempfiles</CITE>. The temp file will now be unlinked as soon as it is created, making it inaccessible to other users. The <STRONG>downside</STRONG> of this is that you will be unable to access this temporary file directly (<CITE>tmpFileName()</CITE> will continue to return a string, but you will find no file at that location.) Further, since PRIVATE_TEMPFILES is a global variable, its setting will affect all instances of CGI.pm if you are running mod_perl. Вы можете work around this limitation by declaring $CGI::PRIVATE_TEMPFILES as a local at the top of your script.
<P>On Windows NT, it is impossible to make a temporary file private. This is because Windows doesn't allow you to delete a file before closing it.
<P>Usually the browser sends along some header information along with the text of the file itself. Currently the headers contain only the original file name and the MIME content type (if known). Future browsers might send other information as well (such as modification date and size). Чтобы вернуть эту информацию, вызовите <STRONG>uploadInfo()</STRONG>. Он возвращает ссылку на ассоциативный массив, содержащий все заголовки документов. Например, этот фрагмент кода возвращает тип MIME выгруженного файла (be careful to use the proper capitalization for "Content-Type"!):
<PRE>
  $filename = $query-&gt;param('выгруженный_файл');
  $type = $query-&gt;uploadInfo($filename)-&gt;{'Content-Type'};
  unless ($type eq 'text/html') { die "ТОЛЬКО ФАЙЛЫ HTML!" }
</PRE>
<P><STRONG>JavaScripting:</STRONG> Like textfield(), filefield() accepts <STRONG>-onChange, -onFocus, -onBlur, -onMouseOver, -onMouseOut</STRONG> and <STRONG>-onSelect</STRONG> parameters to register <A href="#index_html_javascripting">JavaScript</A> event handlers. <A href="#index_html_upload_caveats">Предостережения и потенциальные проблемы в особенности для выгрузки файлов.</A>
<H3><A name="index_html_menu">Создание A Popup Menu</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;popup_menu(-name=&gt;'имя_меню',-values=&gt;[qw/eenie meenie minie/],
                           -labels=&gt;{'eenie'=&gt;'один','meenie'=&gt;'два','minie'=&gt;'три'},
                           -default=&gt;'meenie');

  print $query-&gt;popup_menu(-name=&gt;'имя_меню',
                           -values=&gt;['eenie','meenie','minie'],-default=&gt;'meenie');

  <EM>Старый стиль</EM>
  print $query-&gt;popup_menu('имя_меню',['eenie','meenie','minie'],'meenie',
                          {'eenie'=&gt;'один','meenie'=&gt;'два','minie'=&gt;'три'});
</PRE>
<P><STRONG>popup_menu()</STRONG> создает меню.
<UL>
  <LI><P>Обязательный первый аргумент (<STRONG>-name</STRONG>) - это имя меню.
  <LI><P>Обязательный второй аргумент (<STRONG>-values</STRONG>) is an array <EM>reference</EM> containing the list of menu items in the menu. Вы можете pass the method an anonymous array, as shown in the example, or a reference to a named array, such as <TT>\@foo</TT>. If you pass a <EM>HASH reference</EM>, the keys will be used for the menu values, and the values will be used for the menu labels (смотрите -labels below).
  <LI><P>Необязательный третий параметр (<STRONG>-default</STRONG>) is the name of the default menu choice. If not specified, the first item will be the default. The value of the previous choice will be maintained across queries.
  <LI><P>Необязательный четвертый параметр (<STRONG>-labels</STRONG>) allows you to pass a reference to an associative array containing user-visible labels for one or more of the menu items. Вы можете использовать this when you want the user to see one menu string, but have the browser return your program a different one. If you don't specify this, the value string will be used instead ("eenie","meenie" and "minie" in this example). This is equivalent to using a hash reference for the -values parameter.
</UL>
<P>Когда форма обработана, выбранное значение of the popup menu может быть возвращено, используя:
<PRE>  $popup_menu_value = $query-&gt;param('имя_меню');</PRE>
<P><STRONG>JavaScripting:</STRONG> Вы можете provide <STRONG>-onChange, -onFocus, -onMouseOver, -onMouseOut, and -onBlur</STRONG> parameters to register <A href="#index_html_javascripting">JavaScript</A> event handlers.
<H3><A name="index_html_scrolling_list">Создание списка с возможностью прокрутки</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;scrolling_list(-name=&gt;'имя_списка',
                               -values=&gt;['eenie','meenie','minie','moe'],
                               -default=&gt;['eenie','moe'],
                               -size=&gt;5,
                               -multiple=&gt;'true',
                               -labels=&gt;\%labels);

  <EM>Старый стиль</EM>
  print $query-&gt;scrolling_list('имя_списка',
                              ['eenie','meenie','minie','moe'],
                              ['eenie','moe'],5,'true',
                              \%labels);
</PRE>
<P><STRONG>scrolling_list()</STRONG> создает список с возможностью прокрутки.
<UL>
  <LI><P>Первый и второй аргументы (<STRONG>-name, -values</STRONG>)are the list name and values, respectively. As in the popup menu, the second argument should be an array reference or hash reference. In the latter case, the values of the hash are used as the human-readable labels in the list.
  <LI><P>Необязательный третий аргумент (<STRONG>-default</STRONG>)can be either a reference to a list containing the values to be selected by default, or can be a single value to select. If this argument is missing or undefined, then nothing is selected when the list first appears.
  <LI><P>Необязательный четвертый аргумент (<STRONG>-size</STRONG>) is the display size of the list.
  <LI><P>Необязательный пятый аргумент (<STRONG>-multiple</STRONG>) can be set to true to allow multiple simultaneous selections.
  <LI><P>The option sixth шестой аргумент (<STRONG>-labels</STRONG>) can be used to assign user-visible labels to the list items different from the ones used for the values as above. This is equivalent to passing a hash reference to -values. In this example we assume that an associative array <CODE>%labels</CODE> has already been created.
</UL>
<P>When this form is processed, all selected list items will be returned as a list under the parameter name 'list_name'. Значения выбранных элементов могут быть возвращены вызовом:
<PRE>  @selected = $query-&gt;param('имя_списка');</PRE>
<P><STRONG>JavaScripting:</STRONG> Вы можете provide <STRONG>-onChange, -onFocus, -onMouseOver, -onMouseOut</STRONG> and <STRONG>-onBlur</STRONG> parameters to register <A href="#index_html_javascripting">JavaScript</A> event handlers.
<H3><A name="index_html_checkbox_group">Создание группы связанных выключателей</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;checkbox_group(-name=&gt;'имя_группы',
                               -values=&gt;['eenie','meenie','minie','moe'],
                               -default=&gt;['eenie','moe'],
                               -linebreak=&gt;'true',
                               -labels=&gt;\%labels);

  <EM>Старый стиль</EM>
  print $query-&gt;checkbox_group('имя_группы',
                              ['eenie','meenie','minie','moe'],
                              ['eenie','moe'],'true',\%labels);

  <EM>Только для браузеров HTML&nbsp;3</EM>
  print $query-&gt;checkbox_group(-name=&gt;'имя_группы',
                               -values=&gt;['eenie','meenie','minie','moe'],
                               -rows=&gt;2,-columns=&gt;2);
</PRE>
<P><STRONG>checkbox_group()</STRONG> создает список выключателей, которые связаны одним и тем же именем.
<UL>
  <LI><P>Первый и второй аргументы (<STRONG>-name, -values</STRONG>) - имя выключателя и значения, соответственно. As in the popup menu, the second argument should be an array reference or a hash reference. These values are used for the user-readable labels printed next to the checkboxes as well as for the values passed to your script in the query string.
  <LI><P>Необязательный третий аргумент (<STRONG>-default</STRONG>) can be either a reference to a list containing the values to be checked by default, or can be a single value to checked. If this argument is missing or undefined, then nothing is selected when the list first appears.
  <LI><P>Необязательный четвертый аргумент (<STRONG>-linebreak</STRONG>) can be set to true to place line breaks between the checkboxes so that they appear as a vertical list. Otherwise, they will be strung together on a horizontal line. When the form is procesed, all checked boxes will be returned as a list under the parameter name 'имя_группы'. Значения выключателей "on" могут быть возвращены вызовом:
  <LI><P>Необязательный пятый аргумент (<STRONG>-labels</STRONG>) is a reference to an hash of checkbox labels. This allows you to use different strings for the user-visible button labels and the values sent to your script. In this example we assume that an associative array <CODE>%labels</CODE> has previously been created. This is equivalent to passing a hash reference to -values.
  <LI><P>Необязательный параметр <STRONG>-nolabels</STRONG> can be used to suppress the printing of labels next to the button. This is useful if you want to capture the button elements individually and use them inside labeled HTML&nbsp;3 tables.
  <LI><P><STRONG>Browsers that understand HTML&nbsp;3 tables</STRONG> (such as Netscape) can take advantage of the optional parameters <STRONG>-rows</STRONG>, and <STRONG>-columns</STRONG>. These parameters cause checkbox_group() to return an HTML&nbsp;3 compatible table containing the checkbox group formatted with the specified number of rows and columns. Вы можете provide just the -columns parameter, если вы желаете; checkbox_group will calculate the correct number of rows for you.
  <P>Чтобы включить row and column headings в возращаемую таблицу, вы можете использовать параметры <STRONG>-rowheaders</STRONG> и <STRONG>-colheaders</STRONG>. Both of these accept a pointer to an array of headings to use. The headings are just decorative. They don't reorganize the interpetation of the checkboxes -- they're still a single named unit.
  <P>When viewed with browsers that don't understand HTML&nbsp;3 tables, the -rows and -columns parameters will leave you with a group of buttons that may be awkwardly formatted but still useable. Однако, if you add row and/or column headings, the resulting text will be very hard to read.
</UL>
<P>Когда форма обработана, список of checked buttons в группе может быть возвращен like this:
<PRE>  @turned_on = $query-&gt;param('имя_группы');</PRE>
<P>Эта функция actually возвращает массив of button elements. Вы можете capture the array and do interesting things with it, such as incorporating it into your own tables or lists. The <STRONG>-nolabels</STRONG> option is also useful in this regard:
<PRE>
  @h = $query-&gt;checkbox_group(-name=&gt;'выбор',
                              -value=&gt;['fee','fie','foe'],
                              -nolabels=&gt;1);
  create_nice_table(@h);
</PRE>
<P><STRONG>JavaScripting:</STRONG> Вы можете provide an  параметр <STRONG>-onClick</STRONG>, чтобы зарегистрировать некоторый код <A href="#index_html_javascripting">JavaScript</A> to be performed every time the user clicks on any of the buttons in the group.
<H3><A name="index_html_checkbox">Создание одиночного выключателя</A></H3>
<PRE>
  <EM>Список именованных параметров</EM>
  print $query-&gt;checkbox(-name=&gt;'имя_выключателя',
                         -checked=&gt;'checked',
                         -value=&gt;'ВКЛЮЧЕН',
                         -label=&gt;'Включи меня');

  <EM>Старый стиль</EM>
  print $query-&gt;checkbox('имя_выключателя',1,'ВКЛЮЧЕН','Включи меня');
</PRE>
<P><STRONG>checkbox()</STRONG> используется, чтобы создать изолированный выключатель, который логически не связан с какими-либо другими.
<UL>
  <LI><P>Первый параметр (<STRONG>-name</STRONG> - необходимое имя для выключателя. Он будет также использоваться для the user-readable label printed next to the checkbox.
  <LI><P>Необязательный второй параметр (<STRONG>-checked</STRONG> specifies that the checkbox is turned on by default. Псевдонимы для этого параметра <STRONG>-selected</STRONG> и <STRONG>-on</STRONG>.
  <LI><P>Необязательный третий параметр (<STRONG>-value</STRONG> specifies the value of the checkbox when it is checked. If not provided, the word "on" is assumed.
  <LI><P>Необязательный четвертый параметр (<STRONG>-label</STRONG> assigns a user-visible label to the button. If not provided, будет использоваться имя выключателя.
</UL>
<P>Значение выключателя может быть возвращено, используя:
<PRE>  $turned_on = $query-&gt;param('имя_выключателя');</PRE>
<P><STRONG>JavaScripting:</STRONG> Вы можете provide an параметр <CODE>-onClick</CODE>, чтобы зарегистрировать некоторый код <A href="#index_html_javascripting">JavaScript</A> to be performed every time the user clicks on the button.
<H3><A name="index_html_radio">Создание группы переключателей</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;radio_group(-name=&gt;'имя_группы',
                            -values=&gt;['eenie','meenie','minie'],
                            -default=&gt;'meenie',
                            -linebreak=&gt;'true',
                            -labels=&gt;\%labels);

  <EM>Старый стиль</EM>
  print $query-&gt;radio_group('имя_группы',['eenie','meenie','minie'],'meenie','true',\%labels);

  <EM>Только для браузеров совместимых с HTML 3</EM>
  print $query-&gt;radio_group(-name=&gt;'имя_группы',
                            -values=&gt;['eenie','meenie','minie','moe'],
                            -rows=&gt;2,-columns=&gt;2);
</PRE>
<P><STRONG>radio_group()</STRONG> создает набор логически связанных переключателей. Turning one member of the group on turns the others off.
<UL>
  <LI><P>Первый аргумент (<STRONG>-name</STRONG> - имя группы, и оно необходимо.
  <LI><P>Второй аргумент (<STRONG>-values</STRONG> is the list of values for the radio buttons. The values and the labels that appear on the page are identical. Pass an array <EM>reference</EM> in the second argument, either using an anonymous array, as shown, or by referencing a named array as in <CODE>\@foo</CODE>. You may also use a hash reference чтобы produce human-readable labels that are different from the values that will be returned as parameters to the CGI script.
  <LI><P>Необязательный третий параметр (<STRONG>-default</STRONG> is the value of the default button to turn on. If not specified, the first item will be the default. Specify some nonexistent value, such as "-" if you don't want any button to be turned on.
  <LI><P>Необязательный четвертый параметр (<STRONG>-linebreak</STRONG> can be set to 'true' to put line breaks between the buttons, creating a vertical list.
  <LI><P>Необязательный пятый параметр (<STRONG>-labels</STRONG> specifies an associative array containing labels to be printed next to each button. If not provided the button value will be used instead. This example assumes that the associative array <CODE>%labels</CODE> has already been defined. This is equivalent to passing a hash reference to -values.
  <LI><P>Необязательный параметр <STRONG>-nolabels</STRONG> can be used to suppress the printing of labels next to the button. This is useful if you want to capture the button elements individually and use them inside labeled HTML&nbsp;3 tables.
  <LI><P><STRONG>Браузеры, которые понимают таблицы HTML&nbsp;3</STRONG> (такие как Netscape) can take advantage of the optional parameters <STRONG>-rows</STRONG>, and <STRONG>-columns</STRONG>. These parameters cause radio_group() to return an HTML&nbsp;3 compatible table containing the radio cluster formatted with the specified number of rows and columns. Вы можете provide just the -columns parameter, если вы желаете; radio_group will calculate the correct number of rows for you.
  <P>Чтобы включить row and column headings в возвращаемую таблицу, вы можете использовать параметры <STRONG>-rowheader</STRONG> и <STRONG>-colheader</STRONG>. Both of these accept a pointer to an array of headings to use. The headings are just decorative. They don't reorganize the interpetation of the radio buttons -- they're still a single named unit.
  <P>When viewed with browsers that don't understand HTML&nbsp;3 tables, the -rows and -columns parameters will leave you with a group of buttons that may be awkwardly formatted but still useable. Однако, if you add row and/or column headings, the resulting text will be very hard to read.
</UL>
<P>Когда форма обработана, выбранный переключатель может быть возвращен, используя:
<PRE>  $which_radio_button = $query-&gt;param('имя_группы');</PRE>
<P>Эта функция actually возвращает массив of button elements. Вы можете capture the array and do interesting things with it, such as incorporating it into your own tables or lists The <STRONG>-nolabels</STRONG> option is useful in this regard.:
<PRE>
  @h = $query-&gt;radio_group(-name=&gt;'выбор',
                           -value=&gt;['fee','fie','foe'],
                           -nolabels=&gt;1);
  create_nice_table(@h);
</PRE>
<P><STRONG>JavaScripting</STRONG>: Вы можете provide an параметр <STRONG>-onClick</STRONG>, чтобы зарегистрировать некоторый код <A href="#index_html_javascripting">JavaScript</A> to be performed every time the user clicks on any of the buttons in the group.
<H3><A name="index_html_submit">Создание A Submit Button</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;submit(-name=&gt;'имя_кнопки',
                       -value=&gt;'значение');

  <EM>Старый стиль</EM>
  print $query-&gt;submit('имя_кнопки','значение');
</PRE>
<P><STRONG>submit()</STRONG> создаст the query submission button. Каждая форма should have one of these.
<UL>
  <LI><P>Первый аргумент (<STRONG>-name</STRONG> необязателен. Вы можете give the button a name, если вы имеете несколько submission buttons в своей форме и вы хотите to distinguish between them.
  <LI><P>Второй аргумент (<STRONG>-value</STRONG> также необязателен. This gives the button a value that will be passed to your script in the query string, and will also appear as the user-visible label.
  <P><P>Вы можете figure out which of several buttons was pressed by using different values for each one:
  <PRE>  $which_one = $query-&gt;param('имя_кнопки');</PRE>
  <LI><P>Вы можете использовать <STRONG>-label</STRONG>, как псевдоним для <STRONG>-value</STRONG>. Я always get confused about which of <CODE>-name</CODE> и <CODE>-value</CODE> changes the user-visible label на кнопке.
</UL>
<P><STRONG>JavaScripting:</STRONG> Вы можете provide an параметр <STRONG>-onClick</STRONG>, чтобы зарегистрировать некоторый код <A href="#index_html_javascripting">JavaScript</A> to be performed every time the user clicks on the button. Вы не можете prevent a form from being submitted, однако. Вы должны provide an <STRONG>-onSubmit</STRONG> handler to the <A href="#index_html_forms">form itself</A> to do that.
<H3><A name="index_html_reset">Создание A Reset Button</A></H3>
<PRE>  print $query-&gt;reset</PRE>
<P><STRONG>reset()</STRONG> создает the "reset" button. It undoes whatever changes the user has recently made to the form, but does <STRONG>not</STRONG> necessarily reset the form all the way to the defaults. Смотрите <STRONG>defaults()</STRONG> for that. It takes the optional label for the button ("Reset" by default). <STRONG>JavaScripting:</STRONG> Вы можете provide an <STRONG>-onClick</STRONG> parameter, чтобы зарегистрировать некоторый код <A href="#index_html_javascripting">JavaScript</A> code to be performed every time the user clicks on the button.
<H3><A name="index_html_defaults">Создание A Defaults Button</A></H3>
<PRE>  print $query-&gt;defaults('button_label')</PRE>
<P><STRONG>defaults()</STRONG> создает "reset to defaults" button. It takes the optional label for the button ("Defaults" by default). When the user presses this button, the form will automagically be cleared entirely and set to the defaults you specify in your script, just as it was the first time it was called.
<H3><A name="index_html_hidden">Создание A Hidden Field</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;hidden(-name=&gt;'hidden_name',
                       -default=&gt;['значение1','значение2'...]);

  <EM>Старый стиль</EM>
  print $query-&gt;hidden('hidden_name','значение1','значение2'...);
</PRE>
<P><STRONG>hidden()</STRONG> produces a text field that can't be seen by the user. It is useful for passing state variable information from one invocation of the script to the next.
<UL>
  <LI><P>Первый аргумент (<STRONG>-name</STRONG>) is required and specifies the name of this field.
  <LI><P>Второй и последующие аргументы specify the value for the hidden field. This is a quick and dirty way of passing Perl arrays through forms. If you use the стиль с именованными параметрами, you must provide the parameter <STRONG>-default</STRONG> and an array reference here.
</UL>
<P><STRONG><A name="index_html_hidden_fields_warning">As of version 2.0 I have changed the behavior of hidden fields once again. Read this if you use hidden fields.</A></STRONG>
<P>Hidden fields used to behave differently from all other fields: the provided default values always overrode the "sticky" values. This was the behavior people seemed to expect, однако it turns out to make it harder to write state-maintaining forms such as shopping cart programs. Therefore I have made the behavior consistent with other fields.
<P>Just like all the other form elements, the value of a hidden field is "sticky". If you want to replace a hidden field with some other values after the script has been called once you'll have to do it manually before writing out the form element:
<PRE>
  $query-&gt;param('hidden_name','new','values','here');
  print $query-&gt;hidden('hidden_name');
</PRE>
<P>Fetch the value of a hidden field this way:
<PRE>
  $hidden_value = $query-&gt;param('hidden_name');
    -or (for values created with arrays)-
  @hidden_values = $query-&gt;param('hidden_name');
</PRE>
<H3><A name="index_html_image">Создание a Clickable Image Button</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;image_button(-name=&gt;'имя_кнопки',
                             -src=&gt;'/images/NYNY.gif',
                             -align=&gt;'MIDDLE');

  <EM>Старый стиль</EM>
  print $query-&gt;image_button('имя_кнопки','/source/URL','MIDDLE');
</PRE>
<P><STRONG>image_button()</STRONG> produces an inline image that acts as a submission button. When selected, the form is submitted and the clicked (x,y) coordinates are submitted as well.
<UL>
  <LI><P>Первый аргумент(<STRONG>-name</STRONG> is required and specifies the name of this field.
  <LI><P>Второй аргумент (<STRONG>-src</STRONG>specifies the URL of the image to display. It must be one of the types supported by inline images (например, GIF), but can be any local or remote URL.
  <LI><P>Третий аргумент (<STRONG>-align</STRONG>is anything you might want to use in the ALIGN attribute, such as TOP, BOTTOM, LEFT, RIGHT or MIDDLE. This field is optional.
</UL>
<P>When the image is clicked, the results are passed to your script in two parameters named "button_name.x" and "button_name.y", where "button_name" is the name of the image button.
<PRE>
  $x = $query-&gt;param('button_name.x');
  $y = $query-&gt;param('button_name.y');
</PRE>
<P><STRONG>JavaScripting:</STRONG> Текущие версии JavaScript do not honor the <CODE>-onClick</CODE> handler, unlike other buttons.
<H3><A name="index_html_button">Создание a JavaScript Button</A></H3>
<PRE>
  <EM>Стиль с именованными параметрами</EM>
  print $query-&gt;button(-name=&gt;'кнопка1',
                       -value=&gt;'Нажми меня',
                       -onClick=&gt;'doButton(this)');

  <EM>Старый стиль</EM>
  print $query-&gt;image_button('кнопка1','Нажми меня','doButton(this)');
</PRE>
<P><STRONG>button()</STRONG> создает кнопку JavaScript. Когда the button is pressed, the JavaScript code pointed to by the <CODE>-onClick</CODE> parameter is executed. Это работает только с Netscape&nbsp;2.0 и выше. Другие браузеры не распознают JavaScript и, вероятно, не смогут даже показать кнопку.
<UL>
  <LI><P>Первый аргумент(<STRONG>-name</STRONG> is required and specifies the name of this field.
  <LI><P>Второй аргумент (<STRONG>-value</STRONG> gives the button a value, and will be used as the user-visible label on the button.
  <LI><P>Третий аргумент (<STRONG>-onClick</STRONG> is any valid JavaScript code. It's usually a call to a JavaScript function defined somewhere else (see the <A href="#index_html_html">start_html()</A> method), but can be any JavaScript you like. Multiple lines are allowed, but you must be careful not to include any double quotes in the JavaScript text.
</UL>
<P>Смотрите <A href="#index_html_javascripting">JavaScripting</A> за большей информацией.
<H3><A name="index_html_escape">Controlling HTML Autoescaping</A></H3>
<P>По умолчанию, если вы используете специальный символ HTML, такой как &gt;, &lt; или &amp; как метку или значение кнопки, it will be escaped using the appropriate HTML escape sequence (например, &amp;gt;). This lets you use anything at all for the text of a form field without worrying about breaking the HTML document. Однако, it may also interfere with your ability to use special characters, such as &Aacute; as default contents of fields. Вы можете turn this feature on and off with the method <CODE>autoEscape()</CODE>.
<P>Используйте
<PRE>  $query-&gt;autoEscape(undef);</PRE>
<P>to turn automatic HTML escaping off, and
<PRE>  $query-&gt;autoEscape('true');</PRE>
<P>to turn it back on.
<HR>
<H2><A name="index_html_import">Импортирование методов CGI</A></H2>
<P>A large number of scripts allocate only a single query object, use it to read parameters or to create a fill-out form, and then discard it. For this type of script, it may be handy to import CGI module methods into your name space. The most common syntax for this is:
<PRE>  use CGI qw(:standard);</PRE>
<P>This imports the standard methods into your namespace. Now instead of getting parameters like this:
<PRE>
  use CGI;

  $dinner = $query-&gt;param('entree');
</PRE>
<P>Вы можете do it like this:
<PRE>
  use CGI qw(:standard);

  $dinner = param('entree');
</PRE>
<P>Similarly, instead of creating a form like this:
<PRE>
  print $query-&gt;start_form,
  "Check here if you're happy: ",
  $query-&gt;checkbox(-name=&gt;'happy',-value=&gt;'Y',-checked=&gt;1),
  "&lt;P&gt;",
  $query-&gt;submit,
  $query-&gt;end_form;
</PRE>
<P>Вы можете create it like this:
<PRE>
  print start_form,
  "Check here if you're happy: ",
  checkbox(-name=&gt;'happy',-value=&gt;'Y',-checked=&gt;1),
  p,
  submit,
  end_form;
</PRE>
<P>Even though there's no CGI object in view in the second example, state is maintained using an implicit CGI object that's created automatically. The form elements created this way are sticky, just as before. If you need to get at the implicit CGI object directly, вы можете refer to it as:
<PRE>  $CGI::Q;</PRE>
<P>The <STRONG>use CGI</STRONG> statement используется, чтобы импортировать имена методов в текущее пространство имен. There is a slight overhead for each name you import, but ordinarily is nothing to worry about. Вы можете import selected method names like this:
<PRE>  use CGI qw(header start_html end_html);</PRE>
<P>Ordinarily, однако, you'll want to import groups of methods using export tags. Export tags refer to sets of logically related methods which are imported as a group with <STRONG>use</STRONG>. Tags are distinguished from ordinary methods by beginning with a ":" character. Этот пример импортирует методы dealing with the CGI protocol (<CODE>param()</CODE> and the like) as well as shortcuts that generate HTML&nbsp;2-compliant tags:
<PRE>  use CGI qw(:cgi :html2);</PRE>
<P>Currently существует 8 семейств методов, определенных в CGI.pm. They are:
<DL>
  <DT><P><CITE>:cgi</CITE>
  <DD><P>These are all the tags that support one feature or another of the CGI protocol, including param(), path_info(), cookie(), request_method(), header() and the like.
  <DT><P><CITE>:form</CITE>
  <DD><P>These are all the form element-generating methods, including start_form(), textfield(), etc.
  <DT><P><CITE>:html2</CITE>
  <DD><P>These are HTML&nbsp;2-defined shortcuts such as br(), p() and head(). It also includes such things as start_html() and end_html() that aren't exactly HTML&nbsp;2, but are close enough.
  <DT><P><CITE>:html3</CITE>
  <DD><P>These содержит различные теги HTML&nbsp;3 для таблиц, кадров, super- and subscripts, апплетов и других объектов.
  <DT><P><CITE>:netscape</CITE>
  <DD><P>These are Netscape extensions not included in the HTML&nbsp;3 category including blink() и center().
  <DT><P><CITE>:html</CITE>
  <DD><P>These are all the HTML generating shortcuts, comprising the union of <CITE>html2, html3,</CITE> и <CITE>netscape</CITE>.
  <DT><P><CITE>:multipart</CITE>
  <DD><P>These are various functions that simplify creating documents of the various multipart MIME types, and are useful for implementing server push.
  <DT><P><CITE>:standard</CITE>
  <DD><P>This is the union of <CITE>html2, form,</CITE> and <CITE>:cgi</CITE> (everything except the HTML&nbsp;3 and Netscape extensions).
  <DT><P><CITE>:all</CITE>
  <DD><P>This импортирует все общедоступные методы в ваше пространство имен!
</DL>
<H3>Pragmas</H3>
<P>В дополнение к importing individual methods and method families, <CITE>use CGI</CITE> recognizes several pragmas, all proceeded by dashes.
<DL>
  <DT><P><B>-any</B>
  <DD><P>Когда вы используете <CITE>use CGI -any</CITE>, then any method that the query object doesn't recognize will be interpreted as a new HTML tag. This allows you to support the next <CITE>ad hoc</CITE> Netscape or Microsoft HTML extension. Например, to support Netscape's latest tag, &lt;GRADIENT&gt; (which causes the user's desktop to be flooded with a rotating gradient fill until his machine reboots), вы можете использовать something like this:
  <PRE>
  use CGI qw(-any);

  $q=new CGI;
  print $q-&gt;gradient({speed=&gt;'fast',start=&gt;'red',end=&gt;'blue'});
  </PRE>
  <P>Since using <CITE>any</CITE> causes any mistyped method name to be interpreted as an HTML tag, use it with care or not at all.
  <DT><P><B>-compile</B>
  <DD><P>This causes the indicated autoloaded methods to be compiled up front, rather than deferred to later. Это полезно для скриптов, которые run for an extended period of time under FastCGI or mod_perl, and for those destined to be crunched by Malcom Beattie's Perl compiler. Используйте ее совместно с методами или семействами методов, которые вы планируете использовать.
  <PRE>  use CGI qw(-compile :standard :html3);</PRE>
  <P>или даже
  <PRE>  use CGI qw(-compile :all);</PRE>
  <P>Заметьте, что использование прагмы -compile таким способом будет всегда have the effect of importing the compiled functions into the current namespace. Если вы хотите компилировать без импортирования, используйте метод <A href="#index_html_compile">compile()</A> вместо этого.
  <DT><P><B>-autoload</B>
  <DD><P>Overrides the autoloader so that any function in your program that is not recognized is referred to CGI.pm for possible evaluation. This allows you to use all the CGI.pm functions without adding them to your symbol table, which is of concern for mod_perl users who are worried about memory consumption. <STRONG>Warning:</STRONG> when <EM>-autoload</EM> is in effect, вы не можете использовать "poetry mode" functions without the parenthesis). Use <CITE>hr()</CITE> rather than <CITE>hr</CITE>, or add something like <EM>use subs qw/hr p header/</EM> to the top of your script.
  <DT><P><B>-nph</B>
  <DD><P>This makes CGI.pm produce a header appropriate for an NPH (no parsed header) script. You may need to do other things as well to tell the server that the script is NPH. Смотрите <A href="#index_html_nph">обсуждение скриптов NPH</A> ниже.
  <DT><P><B>-newstyle_urls</B>
  <DD><P>Separate the name=value pairs in CGI parameter query strings with semicolons rather than ampersands. Например:
  <PRE>  ?name=fred;age=24;favorite_color=3</PRE>
  <P>Semicolon-delimited query strings are always accepted, but will not be emitted by <CITE>self_url()</CITE> and <CITE>query_string()</CITE> unless the <B>-newstyle_urls</B> pragma is specified.
  <DT><P><B>-no_debug</B>
  <DD><P>This turns off the command-line processing features. If you want to run a CGI.pm script from the command line to produce HTML, and you don't want it pausing to request CGI parameters from standard input, then use this pragma:
  <PRE>  use CGI qw(-no_debug :standard);</PRE>
  <P>Смотрите <A href="#index_html_debugging">отслеживание (debugging)</A> за большими подробностями.  
  <DT><P><B>-private_tempfiles</B>
  <DD><P>CGI.pm can process uploaded file. Ordinarily it spools the uploaded file   to a temporary directory, then deletes the file when done. Однако, this opens   the risk of eavesdropping as described in the <A href="#index_html_upload">file upload section.</A> Another CGI script author could peek at this data during the upload, even if it is confidential information. On Unix systems, the   <B>-private_tempfiles</B> pragma will cause the temporary file to be unlinked as soon as it is opened and before any data is written into it, eliminating the risk of eavesdropping.
</DL>
<H3>Special Forms for Importing HTML-Tag Functions</H3>
<P>Many of the methods generate HTML tags. As described below, tag functions automatically generate both the opening and closing tags. Например:
<PRE>  print h1('Level 1 Header');</PRE>
<P>produces
<PRE>  &lt;H1&gt;Level 1 Header&lt;/H1&gt;</PRE>
<P>There will be some times when you want to produce the start and end tags yourself. In this case, вы можете использовать the form start_I<CITE>tag_name</CITE> and end_I<CITE>tag_name</CITE>, as in:
<PRE>  print start_h1,'Level 1 Header',end_h1;</PRE>
<P>With a few exceptions (described below), start_<CITE>tag_name</CITE> and end_I<CITE>tag_name</CITE> functions are not generated automatically when you <CITE>use CGI</CITE>. Однако, вы можете specify the tags you want to generate <CITE>start/end</CITE> functions for by putting an asterisk in front of their name, or, alternatively, requesting either "start_<CITE>tag_name</CITE>" or "end_<CITE>tag_name</CITE>" in the import list.
<P>Пример:
<PRE>  use CGI qw/:standard *table start_ul/;</PRE>
<P>In this example, the following functions are generated в дополнение к the standard ones:
<OL>
  <LI><P><CODE>start_table()</CODE> (generates a &lt;TABLE&gt; tag)
  <LI><P><CODE>end_table()</CODE> (generates a &lt;/TABLE&gt; tag)
  <LI><P><CODE>start_ul()</CODE> (generates a &lt;UL&gt; tag)
  <LI><P><CODE>end_ul()</CODE> (generates a &lt;/UL&gt; tag)
</OL>
<H3>PRETTY-PRINTING HTML</H3>
<P>По умолчанию, all the HTML produced этими функциями comes out as one long line без возвратов карретки или indentation. This is yuck, but it does reduce the size of the documents by 10-20%. To get pretty-printed output, please use <CITE>CGI::Pretty</CITE>, a subclass contributed by <A href="mailto:bpaulsen@lehman.com">Brian Paulsen</A>.
<H3>Optional Utility Functions</H3>
<P>В дополнение к the standard imported functions, there are a few optional functions that you must request by name if you want them. They were originally intended for internal use only, but are now made available by popular request.
<H4>escape(), unescape()</H4>
<PRE>
  use CGI qw/escape unescape/;

  $q = escape('This $string contains ~wonderful~ characters');
  $u = unescape($q);
</PRE>
<P>These functions escape and unescape strings according to the URL hex escape rules. Например, the space character will be converted into the string "%20".
<H4>escapeHTML(), unescapeHTML()</H4>
<PRE>
  use CGI qw/escapeHTML unescapeHTML/;

  $q = escapeHTML('This string is &lt;illegal&gt; html!');
  $u = unescapeHTML($q);
</PRE>
<P>These functions escape and unescape strings according to the HTML character entity rules. Например, the character &lt; will be escaped as &amp;lt;.
<H4><A name="index_html_compile">compile()</A></H4>
<P>Ordinarily CGI.pm autoloads most of its functions on an as-needed basis. This speeds up the loading time by deferring the compilation phase. Однако, если you are using mod_perl, FastCGI or another system that uses a persistent интерпретатор Perl, you will want to precompile the methods at initialization time. To accomplish this, call the package function <B>compile()</B> like this:
<PRE>
  use CGI ();

  CGI-&gt;compile(':all');
</PRE>
<P>The arguments to <B>compile()</B> are a list of method names or sets, and are identical to those accepted by the use operator.
<HR>
<H2><A name="index_html_debugging">Отслеживание (debugging)</A></H2>
<P>Если вы are running the script from the command line or in the Perl debugger, вы можете pass the script a list of keywords or parameter=value pairs on the command line or from standard input (you don't have to worry about tricking your script into reading from environment variables). Вы можете pass keywords like this:
<PRE>  my_script.pl keyword1 keyword2 keyword3</PRE>
<P><EM>or this:</EM>
<PRE>  my_script.pl keyword1+keyword2+keyword3</PRE>
<P><EM>or this:</EM>
<PRE>  my_script.pl name1=value1 name2=value2</PRE>
<P><EM>or this:</EM>
<PRE>  my_script.pl name1=value1&amp;name2=value2</PRE>
<P>или даже by sending newline-delimited parameters to standard input:
<PRE>
  % my_script.pl
  first_name=fred
  last_name=flintstone
  occupation='granite miner'
  ^D
</PRE>
<P>When debugging, вы можете использовать quotation marks and the backslash character to escape spaces and other funny characters in exactly the way you would in the shell (which isn't surprising since CGI.pm uses "shellwords.pl" internally). This lets you do this sort of thing:
<PRE>  my_script.pl 'name 1=I am a long value' name\ 2=two\ words</PRE>
<P>If you run a script that uses CGI.pm from the command line and fail to provide it with any arguments, it will print out the line
<PRE>  (offline mode: enter name=value pairs on standard input)</PRE>
<P>then appear to hang. In fact, the library is waiting for you to give it some parameters to process on its standard input. If you want to give it some parameters, enter them as shown above, then indicate that you're finished with input by pressing ^D (^Z on NT/DOS systems). If you don't want to give CGI.pm parameters, just press ^D.
<P>Вы можете suppress this behavior in any of the following ways:
<DL>
  <DT><P>1. Call the script with an empty parameter.
  <DD><P>Пример:
  <PRE>  my_script.pl ''</PRE>
  <DT><P>2. Redirect standard input from /dev/null or an empty file.
  <DD><P>Пример:
  <PRE>  my_script.pl &lt;/dev/null</PRE>
  <DT><P>3. Include "-no_debug" in the list of symbols to import on the "use" line.
  <DD><P>Пример:
  <PRE>   use CGI qw/:standard -no_debug/;</PRE>
</DL>
<P><A href="#index_html_contents">Содержание</A>
<H3><A name="index_html_dumping">Dumping Out All The Name/Value Pairs</A></H3>
<P>Метод <STRONG>dump()</STRONG> produces a string consisting of all the query's name/value pairs formatted nicely as a nested list. This is useful for debugging purposes:
<PRE>  print $query-&gt;dump</PRE>
<P>Produces something that looks like this:
<PRE>
  &lt;UL&gt;
    &lt;LI&gt;name1
    &lt;UL&gt;
      &lt;LI&gt;value1
      &lt;LI&gt;value2
    &lt;/UL&gt;
    &lt;LI&gt;name2
    &lt;UL&gt;
       &lt;LI&gt;value1
    &lt;/UL&gt;
  &lt;/UL&gt;
</PRE>
<P>Вы можете достичь того же эффекта включением объекта CGI прямо в стоку, как в:
<PRE>  print "&lt;H2&gt;Current Contents:&lt;/H2&gt;\n$query\n";</PRE>
<HR>
<H2><A name="index_html_environment">Переменные сессии HTTP</A></H2>
<P>Некоторые из более полезных переменных окружения могут быть fetched through this interface. The methods are as follows:
<DL>
  <DT><P>Accept()
  <DD><P>Возвращает список типов MIME, которые удаленный браузер принимает. Если вы дадите этому методу один аргумент corresponding to a MIME type, as in <CODE>$query-&gt;Accept('text/html')</CODE>, он вернет a floating point value corresponding to the browser's preference for this type from 0.0 (don't want) to 1.0. Glob types (например, text/*) in the browser's accept list are handled correctly. Заметьте the capitalization of the initial letter. This avoids conflict with the Perl built-in accept().
  <DT><P>auth_type()
  <DD><P>Возвращает the authorization type, if protection is active. Пример "Basic".
  <DT><P><A name="index_html_raw_cookie">raw_cookie()</A>
  <DD><P>Возвращает the "magic cookie" maintained by Netscape&nbsp;1.1 и выше в сыром состоянии. Вы вероятно захотите использовать <A href="http://stein.cshl.org/WWW/software/CGI/cookies">cookie()</A> instead, which gives you a high-level interface to the cookie functions. Called with no parameters, raw_cookie() возвращает the entire cookie structure, which may consist of several cookies appended together (вы можете recover individual cookies by splitting on the "; " sequence. Called with the name of a cookie, возвращает the unescaped value of the cookie as set by the server. This may be useful for retrieving cookies that your script did not set.
  <DT><P><A name="index_html_path_info">path_info()</A>
  <DD><P>Возвращает дополнительную информацию о пути из URL скрипта. Например, fetching <CODE>/cgi-bin/your_script/additional/stuff</CODE> will result in <CODE>$query-&gt;path_info()</CODE> returning <CODE>"/additional/stuff"</CODE>. В дополнение к reading the path information, вы можете set it by giving path_info() an optional string argument. The argument is expected to begin with a "/". Если not present, one will be added for you. The new path information will be returned by subsequent calls to path_info(), and will be incorporated into the URL generated by self_url().
  <DT><P>path_translated()
  <DD><P>As per path_info() но возвращает дополнительную информацию о пути translated into a physical path, например, <CODE>"/usr/local/etc/httpd/htdocs/additional/stuff"</CODE>. Вы не можете change the path_translated, nor will setting the additional path information change this value. The reason for this restriction is that the translation of path information into a physical path is ordinarily done by the server in a layer that is inaccessible to CGI scripts.
  <DT><P>query_string()
  <DD><P>Возращает строку запроса, годную для состояния поддержки.
  <DT><P>referer()
  <DD><P>Возвращает URL страницы, которую браузер просматривал до fetching your script. Not available для всех браузеров.
  <DT><P>remote_addr()
  <DD><P>Возвращает адрес IP удаленного хоста, разделенный точками.
  <DT><P>remote_ident()
  <DD><P>Возвращает the identity-checking information from the remote host. Only available, если удаленный хост has the identd daemon turned on.
  <DT><P>remote_host()
  <DD><P>Возращает или имя удаленного хоста или адрес IP, если первый не имеется в наличии.
  <DT><P>remote_user()
  <DD><P>Возвращает имя given by the remote user during password authorization.
  <DT><P>request_method()
  <DD><P>Возвращает метод HTTP, использованный to request your script's URL, обычно один из <CODE>GET, POST</CODE> или <CODE>HEAD</CODE>.
  <DT><P>script_name()
  <DD><P>Возвращает имя скрипта, как частичный URL, для self-refering скриптов.
  <DT><P>server_name()
  <DD><P>Возвращает имя сервера WWW, под которым запускается скрипт.
  <DT><P>server_software()
  <DD><P>Возвращает имя и версию программного обеспечения сервера.
  <DT><P>virtual_host()
  <DD><P>Когда using the virtual host feature of some servers, возвращает the name of the virtual host the browser is accessing.
  <DT><P>server_port()
  <DD><P>Возвращает коммуникационный порт, который сервер использует.
  <DT><P>user_agent()
  <DD><P>Возвращает идентификатор программного обеспечения браузера удаленного хоста, например, "Mozilla/1.1N (Macintosh; I; 68K)"
  <DT><P>user_name()
  <DD><P>Пытается получить имя удаленного пользователя, используя множество переменных окружения. Это работает только со старыми браузера такими как Mosaic. Netscape does not reliably report имя пользователя!
  <DT><P>http()
  <DD><P>Called with no arguments возвращает список переменных окружения HTTP, включая такие вещи как HTTP_USER_AGENT, HTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to the like-named HTTP header fields in the request. Called with the name of an HTTP header field, возвращает его значение. Capitalization and the use of hyphens versus underscores are not significant.
  <P>Например, все три из этих примеров эквивалентны:
  <PRE>
  $requested_language = $q-&gt;http('Accept-language');
  $requested_language = $q-&gt;http('Accept_language');
  $requested_language = $q-&gt;http('HTTP_ACCEPT_LANGUAGE');
  </PRE>
  <DT><P>https()
  <DD><P>The same as http(), но operates on the HTTPS environment variables present when the SSL protocol is in effect. Может использоваться, чтобы определить, включен ли SSL.
</DL>
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_cookies">HTTP Cookies</A></H2>
<P>Браузеры Netscape версии 1.1 и выше и все версии Internet Explorer поддерживают так называемые "cookie", разработанные чтобы поддерживать состояние внутри сессии браузера. CGI.pm имеет несколько методов, которые поддерживают cookie.
<P>Cookie - это пары имя=значение, сильно похожие на именованные параметры в строке запроса CGI. Скрипты CGI создают одно или более cookie и посылают их браузеру в заголовке HTTP. Браузер поддерживает список cookie, которые принадлежат определенному серверу Web, и возвращает их в скрипт CGI во время последующего взаимодействия.
<P>В дополнение к обязательной паре имя=значение, каждое cookie имеет несколько необязательных атрибутов:
<DL>
  <DT><P>срок истечения
  <DD><P>Это строка времени/даты (в специальном формате GMT), которая указывает, когда cookie истекает. Cookie будет сохраняться и возвращаться в ваш скрипт до того времени, когда эта дата истечения будет достигнута, если пользователь выходит из браузера и перезапускает его. Если дата истечения не определена, cookie будет оставаться активным до того времени, когда пользователь покинет браузер.
  <P>Отрицательные сроки истечения (например, "-1d") велят некоторым браузерам удалить cookie из его постоянного хранилища. Это плохо документированная особенность.
  <DT><P>домен
  <DD><P>Это частичное или полное имя домена, для которого cookie действительно. Браузер будет возвращать cookie любому хосту, который совпадает с частичным именем домена. Например, если вы определяете имя домена ".capricorn.com", тогда браузер вернет cookie серверам Web running на любой из машин "www.capricorn.com", "www2.capricorn.com", "feckless.capricorn.com" и т.п. Имя домена должно содержать по крайней мере два периода, чтобы препятствовать попыткам совпадений с доменами верхнего уровня вроде ".edu". Если не определен никакой домен, тогда браузер будет возвращать cookie только серверам на хосте, откуда создано cookie.
  <DT><P>путь
  <DD><P>Если вы provide a атрибут пути cookie, браузер will check it against your script's URL before returning the cookie. Например, если вы определяете путь "/cgi-bin", тогда cookie будет возвращено в каждый из скриптов "/cgi-bin/tally.pl", "/cgi-bin/order.pl", и "/cgi-bin/customer_service/complain.pl", но не в скрипт "/cgi-private/site_admin.pl". По умолчанию путь установлен в "/", который велит cookie быть посланным любому скрипту CGI на вашем сайте.
  <DT><P>флаг "безопасный"
  <DD><P>Если атрибут "безопасный" установлен, cookie будет послан вашему скрипту, только если запрос CGI происходит на безопасном канале, таком как SSL.
</DL>
<P>Интерфейс к HTTP cookie - метод <STRONG>cookie()</STRONG>:
<PRE>
  $cookie = $query-&gt;cookie(-name=&gt;'sessionID',
                           -value=&gt;'xyzzy',
                           -expires=&gt;'+1h',
                           -path=&gt;'/cgi-bin/database',
                           -domain=&gt;'.capricorn.org',
                           -secure=&gt;1);
  print $query-&gt;header(-cookie=&gt;$cookie);
</PRE>
<P><STRONG>cookie()</STRONG> создает новое cookie. Его параметры включают:
<DL>
  <DT><P><STRONG>-name</STRONG>
  <DD><P>Имя cookie (необходимо). Это может быть вообще любая строка. Хотя Netscape ограничивает свои имена cookie безпробельными альфачисловыми символами, CGI.pm убирает это ограничение при помощи escaping и unescaping cookie за кулисами.
  <DT><P><STRONG>-value</STRONG> 
  <DD><P>Значение cookie. Это может быть любое скалярное значение, ссылка на массив или даже ссылка на ассоциативный массив. Например, вы можете сохранить целый ассоциативный массив в cookie таким образом:
  <PRE>
  $cookie=$query-&gt;cookie(-name=&gt;'семейная информация',
                         -value=&gt;\%childrens_ages);
  </PRE>
  <DT><P><STRONG>-path</STRONG>
  <DD><P>Необязательный частичный путь, для которого это cookie будет действительно, как описано выше.
  <DT><P><STRONG>-domain</STRONG>
  <DD><P>Необязательный частичный домен, для которого это cookie будет действительно, как описано выше.
  <DT><P><STRONG>-expires</STRONG>
  <DD><P>Необязательная дата истечения для этого cookie. Формат описан в разделе по методу <STRONG>header()</STRONG>:
  <PRE>  "+1h"  один час с настоящего момента</PRE>
  <DT><P><STRONG>-secure</STRONG>
  <DD><P>Если установлен в true, это cookie будет использоваться только внутри безопасной сессии SSL.
</DL>
<P>Cookie, созданное методом <STRONG>cookie()</STRONG> должно быть включено в заголовок HTTP в строке, возвращаемой методом <A href="#index_html_header">header()</A>:
<PRE>  print $query-&gt;header(-cookie=&gt;$my_cookie);</PRE>
<P>Чтобы создать множество cookie, дайте методу header() ссылку на массив:
<PRE>
  $cookie1 = $query-&gt;cookie(-name=&gt;'название_загадки',
                            -value=&gt;"Вопрос Сфинкса");
  $cookie2 = $query-&gt;cookie(-name=&gt;'ответы',
                            -value=&gt;\%answers);
  print $query-&gt;header(-cookie=&gt;[$cookie1,$cookie2]);
</PRE>
<P>Чтобы вернуть cookie, запросите его по имени вызовом метода cookie() без параметра <STRONG>-value</STRONG>:
<PRE>
  use CGI;

  $query = new CGI;
  %answers = $query-&gt;cookie('ответы');
  # $query-&gt;cookie(-name=&gt;'ответы') тоже работает!
</PRE>
<P>Чтобы вернуть имена всех cookie, переданных вашему скрипту, вызовите <STRONG>cookie()</STRONG> без каких-либо параметров. Это позволит вам повторять через все cookie:
<PRE>  foreach $name ($query-&gt;cookie()) { print $query-&gt;cookie($name) }</PRE>
<P>Пространства имен cookie и CGI - отдельные. Если вы имеете параметр, названный 'ответы', и cookie, названное 'ответы', значения, возвращенные методами param() и cookie() независимы друг от друга. Однако, можно просто превратить параметр CGI в cookie, и наоборот:
<PRE>
  # превращение параметра CGI в cookie
  $c=$q-&gt;cookie(-name=&gt;'ответы',-value=&gt;[$q-&gt;param('ответы')]);
  # наоборот
  $q-&gt;param(-name=&gt;'ответы',-value=&gt;[$q-&gt;cookie('ответы')]);
</PRE>
<P>Смотрите пример скрипта <A href="http://stein.cshl.org/WWW/software/CGI/examples/cookie.cgi">cookie.cgi</A> за некоторыми идеями того, как эффективно использовать cookie.
<P><STRONG>ЗАМЕЧАНИЕ:</STRONG> Существуют некоторые ограничения на cookie. Вот, что утверждает RFC2109, раздел 6.3:
<PRE>
  Practical user agent implementations have limits on the number and size of cookies that  they
  can store. In general, user agents' cookie support should have no fixed limits.  They  should
  strive to store as many frequently-used cookies as possible.  Furthermore,  general-use  user
  agents should provide each of the following minimum capabilities individually,  although  not
  necessarily simultaneously:

      * at least 300 cookies

      * at least 4096 bytes per cookie (as measured by the size of the characters that comprise
        the cookie non-terminal in the syntax description of the Set-Cookie header)

      * at least 20 cookies per unique host or domain name

   User agents created for specific purposes or for limited-capacity devices should provide  at
   least 20 cookies of 4096 bytes, to ensure that the user can interact with  a   session-based
   origin server.

   The information in a Set-Cookie response header must be retained in  its  entirety.  If  for
   some reason there is inadequate space to  store  the  cookie,  it  must  be  discarded,  not
   truncated.

   Applications should use as few and as  small  cookies  as  possible, and  they  should  cope
   gracefully with the loss of a cookie.
</PRE>
<P>К сожалению, некоторые браузеры appear to have limits that are more restrictive than those given in the RFC. If you need to store a lot of information, it's probably better to create a unique session ID, store it in a cookie, and use the session ID to locate an external file/database saved on the server's side of the connection.
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_frames">Поддержка кадров (frame)</A></H2>
<P>CGI.pm содержит поддержку <A href="http://home.netscape.com/assist/net_sites/frames.html">кадров HTML</A>, особенности Netscape&nbsp;2.0 и выше и Internet Explorer&nbsp;3.0 и выше. Кадры поддерживаются двумя путями:
<OL>
  <LI><P>Вы можете направить выходную информацию скрипта в новое окно или в заранее существующий именованный кадр, предоставив имя кадра как аргумент <CODE>-target</CODE> в методе заголовка. Например, следующий код создаст новое окно и демонстрирует выходную информацию скрипта:
  <PRE>
  $query = new CGI;
  print $query-&gt;header(-target=&gt;'_blank');
  </PRE>
  <LI><P>Вы можете предоставить имя нового или заранее существующего кадра в методах startform() и start_multipart_form(), используя параметр <CODE>-target</CODE>. Когда форма отправлена, выходная информация будет перенаправлена в указанный кадр:
  <PRE>  print $query-&gt;start_form(-target=&gt;'результирующий_кадр');</PRE>
</OL>
<P>Эффективное использование кадров может быть сложным. Создание подходящего набора кадров, в котором запрос и отклик демонстрируются рядом, потребует от вас разделить скрипт на три функциональных раздела. Первый раздел должен создать объявление &lt;frameset&gt; и выйти. Второй раздел ответственен за создание формы запроса и направление его в один кадр. Третий раздел ответственен за создание отклика и направление его в другой кадр.
<P><A href="http://stein.cshl.org/WWW/software/CGI/examples/">Каталог примеров</A> содержит скрипт, называющийся <A href="http://stein.cshl.org/WWW/software/CGI/examples/popup.cgi">popup.cgi</A>, который демонстрирует простое всплывающее окно. <A href="http://stein.cshl.org/WWW/software/CGI/examples/frameset.cgi">frameset.cgi</A> представляет каркас ный скрипт для создания смежных наборов кадров запрос/результат.
<HR>
<H2><A name="index_html_javascripting">Поддержка JavaScript</A></H2>
<P>Версии Netscape&nbsp;2.0 и выше содержат интерпретируемый язык, называемый JavaScript. Internet Explorer&nbsp;3.0 и выше поддерживает тесно связанный диалект, называемый JScript. JavaScript - это не то же самое, что Java, и конечно совсем не то, что Perl, - большая жалость. JavaScript допускает вас к программному изменению содержимого заполняемых форм, созданию новых окон и всплывающих диалоговых окон изнутри самого Netscape. С точки зрения CGI-скриптинга, JavaScript вполне полезен для подтверждения заполняемых форм до их отправки.
<P>Вам нужно знать JavaScript, чтобы использовать его. <A href="http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/">Руководство по Netscape JavaScript</A> содержит хороший учебник и справочник по языку программирования JavaScript.
<P>Обычный способ использования JavaScript - определить набор функций в блоке &lt;SCRIPT&gt; внутри заголовка HTML, а потом зарегистрировать обработчики событий в различных элементах страницы. События включают такие вещи, как прохождение мыши над элементом формы, щелчок по кнопке, изменение содержимого текстового поля или отправка формы. Когда происходит событие, включающее элемент, который зарегистрировал обработчик события, вызывается связанный с ним код JavaScript.
<P>Элементы, которые могут регистрировать обработчики событий, включают &lt;BODY&gt; документа HTML, гипертектовые ссылки, все разнообразные элементы заполняемых форм и саму форму. Существует большое количество событий, и каждое применяется только к тем элементам, для которых оно уместно. Вот неполный список:
<DL>
  <DT><P><B>onLoad</B>
  <DD><P>Браузер загружает текущий документ. Действительно:
  <UL>
    <LI><P>только в разделе HTML &lt;BODY&gt;.
  </UL>
  <DT><P><B>onUnload</B>
  <DD><P>Браузер закрывает текущую страницу или кадр. Действительно:
  <UL>
    <LI><P>только в разделе HTML &lt;BODY&gt;.
  </UL>
  <DT><P><B>onSubmit</B>
  <DD><P>Пользователь нажал кнопку отправки формы. Это событие случается перед самой отправкой формы, и ваша функция может вернуть значение <EM>false</EM>, чтобы приостановить отправку. Действительно:
  <UL>
    <LI><P>только для форм.
  </UL>
  <DT><P><B>onClick</B>
  <DD><P>Мышка щелкнула по элементу в заполняемой форме. Действительно для:
  <UL>
    <LI><P>кнопок (включая кнопки отправки, переустановки и кнопки-изображения)
    <LI><P>выключателей
    <LI><P>переключателей
  </UL>
  <DT><P><B>onChange</B>
  <DD><P>Пользователь изменил содержимое поля. Действительно для:
  <UL>
    <LI><P>текстовых полей
    <LI><P>Text areas
    <LI><P>полей пароля
    <LI><P>файловых полей
    <LI><P>Popup Menus
    <LI><P>списков с возможностью прокрутки
  </UL>
  <DT><P><B>onFocus</B>
  <DD><P>Пользователь выбрал поле, чтобы работать с ним. Действительно для:
  <UL>
    <LI><P>текстовых полей
    <LI><P>Text areas
    <LI><P>полей пароля
    <LI><P>файловых полей
    <LI><P>Popup Menus
    <LI><P>списков с возможностью прокрутки
  </UL>
  <DT><P><B>onBlur</B>
  <DD><P>Пользователь отказался от выбора поля (ушел работать где-то еще). Действительно для:
  <UL>
    <LI><P>текстовых полей
    <LI><P>Text areas
    <LI><P>полей пароля
    <LI><P>файловых полей
    <LI><P>Popup Menus
    <LI><P>списков с возможностью прокрутки
  </UL>
  <DT><P><B>onSelect</B>
  <DD><P>Пользователь изменил часть текстового поля, которая выделена. Действительно для:
  <UL>
    <LI><P>текстовых полей
    <LI><P>Text areas
    <LI><P>полей пароля
    <LI><P>файловых полей
  </UL>
  <DT><P><B>onMouseOver</B>
  <DD><P>Мышь движется над элементом. Действительно для:
  <UL>
    <LI><P>текстовых полей
    <LI><P>Text areas
    <LI><P>полей пароля
    <LI><P>файловых полей
    <LI><P>Popup Menus
    <LI><P>списков с возможностью прокрутки
  </UL>
  <DT><P><B>onMouseOut</B>
  <DD><P>Мышь покидает элемент. Действительно для:
  <UL>
    <LI><P>текстовых полей
    <LI><P>Text areas
    <LI><P>полей пароля
    <LI><P>файловых полей
    <LI><P>Popup Menus
    <LI><P>списков с возможностью прокрутки
  </UL>
</DL>
<P>Чтобы register a JavaScript event handler with an HTML element, just use the event name as a parameter when you call the corresponding CGI method. Например, to have your <CODE>validateAge()</CODE> код JavaScript executed every time the textfield named "age" changes, generate the field like this:
<PRE>  print $q-&gt;textfield(-name=&gt;'age',-onChange=&gt;"validateAge(this)");</PRE>
<P>This example assumes that you've already declared the <CODE>validateAge()</CODE> function by incorporating it into a &lt;SCRIPT&gt; block. The CGI.pm <A href="#index_html_html">start_html()</A> method provides a convenient way to create this section.
<P>Similarly, вы можете create a form that checks itself over for consistency and alerts the user if some essential value is missing by creating it this way:
<PRE>  print $q-&gt;startform(-onSubmit=&gt;"validateMe(this)");</PRE>
<P>Посмотрите скрипт <A href="http://stein.cshl.org/WWW/software/CGI/examples/javascript.cgi">javascript.cgi</A> для демонстрации того, как это все работает.
<P>The JavaScript "standard" is still evolving, which means that new handlers may be added in the future, or may be present in some browsers and not in others. You do not need to wait for a new version of CGI.pm to use new event handlers. Just like any other tag attribute they will produce syntactically correct HTML. For instance, if Microsoft invents a new event handler called <STRONG>onInterplanetaryDisaster</STRONG>, вы можете install a handler for it with:
<PRE>  print button(-name=&gt;'bail out',-onInterPlanetaryDisaster=&gt;"alert('uh oh')");</PRE>
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_stylesheets">Ограниченная поддержка каскадных таблиц стилей</A></H2>
<P>CGI.pm имеет ограниченную поддержку каскадных таблиц стилей HTML&nbsp;3 (css). Чтобы включить таблицу стилей в ваш документ, передайте методу <STRONG>start_html()</STRONG> параметр <STRONG>-style</STRONG>. Значение этого параметра может быть скаляром, в этом случае он будет включается прямо в раздел &lt;STYLE&gt;, или он может быть ссылкой на хеш. В последнем случае вам следует снабдить хеш одним или более <STRONG>-src</STRONG> и <STRONG>-code</STRONG>. <STRONG>-src</STRONG> указывает на URL, где может быть найдена внешне определенная таблица стилей. <STRONG>-code</STRONG> указывает на скалярное значение, которое нужно включить в раздел &lt;STYLE&gt;. Определения стилей в  <STRONG>-code</STRONG> перекрывают сходно называющиеся в <STRONG>-src</STRONG>, отсюда и название "каскадные".
<P>Вы можете также определить тип MIME таблицы стилей, включением необязательного параметра <STRONG>-type</STRONG> в хеш, указанный при помощи <STRONG>-style</STRONG>. Если он не определен, тип устанавливается по умолчанию в 'text/css'.
<P>Чтобы сослаться на стиль в теле вашего документа, добавьте параметр <STRONG>-class</STRONG> к любому элементу HTML:
<PRE>  print h1({-class=&gt;'Фантазия'},'Добро пожаловать на вечеринку');</PRE>
<P>Или определите стили на лету параметром <STRONG>-style</STRONG>:
<PRE>  print h1({-style=&gt;'Color: red;'},'Добро пожаловать в ад');</PRE>
<P>Вы можете также использовать новый элемент <STRONG>span()</STRONG>, чтобы применить стиль к разделу текста:
<PRE>
  print span({-style=&gt;'Color: red;'},
             h1('Добро пожаловать в ад'),
             "Куда делась та корзинка?");
</PRE>
<P>Заметьте, что вы должны импортировать определения ":html3", чтобы получить методы <STRONG>span()</STRONG> и <STRONG>style()</STRONG>.
<P>Вы не сможете сделать много с этим, если вы не поймете спецификации CSS. Более интуитивная subclassable библиотека для каскадных таблиц стилей в Perl is in the works, но до того времени, пожалуйста, прочитайте спецификацию CSS по адресу <A href="http://www.w3.org/pub/WWW/Style/">http://www.w3.org/pub/WWW/Style/</A>, чтобы узнать, как использовать эти особенности. Вот окончательный пример, чтобы вы начали.
<PRE>
  use CGI qw/:standard :html3/;

  #вот таблица стилей, включенная прямо в страницу
  $newStyle=&lt;&lt;END;
  &lt;!-- 
    P.Tip {
      margin-right: 50pt;
      margin-left: 50pt;
      color: red;
    }
    P.Alert {
      font-size: 30pt;
      font-family: sans-serif;
      color: red;
    }
  --&gt;
  END
  print header();
  print start_html(-title=&gt;'CGI со стилем',
                   -style=&gt;{-src=&gt;'http://www.capricorn.com/style/st1.css',
                   -code=&gt;$newStyle});
  print h1('CGI со стилем'),
    p({-class=&gt;'Tip'},
      "Лучше прочитайте спецификацию каскадных таблиц стилей перед тем, как играть с этим!"),
    span({-style=&gt;'color: magenta'},"Смотри, мам, нету рук!",
         p(),"Whooo wee!");
 print end_html;
</PRE>
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_nph">Использование скриптов NPH</A></H2>
<P>NPH, or "no-parsed-header", scripts bypass the server completely by sending the complete HTTP header directly to the browser. This has slight performance benefits, but is of most use for taking advantage of HTTP extensions that are not directly supported by your server, such as server push and PICS headers. 
<P>Servers use a variety of conventions for designating CGI scripts as NPH. Many Unix servers look at the beginning of the script's name for the prefix "nph-". The Macintosh WebSTAR server and Microsoft's Internet Information Server, in contrast, try to decide whether a program is an NPH script by examining the first line of script output.
<P>CGI.pm supports NPH scripts with a special NPH mode. When in this mode, CGI.pm will output the necessary extra header information when the <CODE>header()</CODE> and <CODE>redirect()</CODE> methods are called.
<P><STRONG>Important:</STRONG> If you use the Microsoft Internet Information Server, you <EM>must</EM> designate your script as an NPH script. Otherwise many of CGI.pm's features, such as redirection and the ability to output non-HTML files, will fail.
<P>There are a number of ways to put CGI.pm into NPH mode:
<DL>
  <DT><P>In the <STRONG>use</STRONG> statement:
  <DD><P>Simply add "-nph" to the list of symbols to be imported into your script:
  <PRE>  use CGI qw(:standard -nph)</PRE>
  <DT><P>By calling the <STRONG>nph()</STRONG> method:
  <DD><P>Call <STRONG>nph()</STRONG> with a non-zero parameter at any point after using CGI.pm in your program.
  <PRE>  CGI-&gt;nph(1)</PRE>
  <DT><P>By using <STRONG>-nph</STRONG> parameters in the <STRONG>header()</STRONG> and <STRONG>redirect()</STRONG> statements:
  <DD><PRE>  print $q-&gt;header(-nph=&gt;1);</PRE>
</DL>
<HR>
<H2><A name="index_html_advanced">Продвинутые приемы</A></H2>
<H3>Скрипт, который сохраняет некоторую информацию в файл и восстанавливает ее</H3>
<P>Этот скрипт будет сохранять свое состояние в файл of the user's choosing, когда нажата кнопка "сохранить", и будет восстанавливать его состояние, когда нажата кнопка "восстановить". Заметьте, что <EM>it's very important to check the file name</EM> for shell metacharacters so that the script doesn't inadvertently open up a command or overwrite someone's file. For this to work, the script's current directory must be writable by "nobody".
<PRE>
  #!/usr/local/bin/perl
  use CGI;

  $query = new CGI;
  print $query-&gt;header;
  print $query-&gt;start_html("Save and Restore Example");
  print "&lt;H1&gt;Save and Restore Example&lt;/H1&gt;\n";

  # Here's where we take action on the previous request
  &amp;save_parameters($query)              if $query-&gt;param('action') eq 'сохранить';
  $query = &amp;restore_parameters($query)  if $query-&gt;param('action') eq 'восстановить';

  # Here's where we create the form
  print $query-&gt;startform;
  print "Popup 1: ",$query-&gt;popup_menu('popup1',['eenie','meenie','minie']),"\n";
  print "Popup 2: ",$query-&gt;popup_menu('popup2',['et','lux','perpetua']),"\n";
  print "&lt;P&gt;";
  print "Save/restore state from file: ",$query-&gt;textfield('savefile','state.sav'),"\n";
  print "&lt;P&gt;";
  print $query-&gt;submit('action','сохранить'),$query-&gt;submit('action','восстановить');
  print $query-&gt;submit('action','usual query');
  print $query-&gt;endform;

  # Here we print out a bit at the end
  print $query-&gt;end_html;

  sub save_parameters {
    local($query) = @_;
    local($filename) = &amp;clean_name($query-&gt;param('savefile'));
    if(open(FILE,"&gt;$filename")) {
      $query-&gt;save(FILE);
      close FILE;
      print "&lt;STRONG&gt;State has been saved to file $filename&lt;/STRONG&gt;\n";
    } else { print "&lt;STRONG&gt;Error:&lt;/STRONG&gt; couldn't write to file $filename: $!\n" }
  }

  sub restore_parameters {
    local($query) = @_;
    local($filename) = &amp;clean_name($query-&gt;param('savefile'));
    if(open(FILE,$filename)) {
      $query = new CGI(FILE);  # Throw out the old query, replace it with a new one
      close FILE;
      print "&lt;STRONG&gt;State has been restored from file $filename&lt;/STRONG&gt;\n";
    } else { print "&lt;STRONG&gt;Error:&lt;/STRONG&gt; couldn't restore file $filename: $!\n" }
    return $query;
  }

  # Very important subroutine -- get rid of all the naughty
  # metacharacters from the file name. If there are, we
  # complain bitterly and die.
  sub clean_name {
    local($name) = @_;
    unless ($name=~/^[\w\._-]+$/) {
      print "&lt;STRONG&gt;$name has naughty characters. Only ";
      print "alphanumerics are allowed. Вы не можете использовать absolute names.&lt;/STRONG&gt;";
      die "Attempt to use naughty characters";
   }
   return $name;
  }
</PRE>
<P>If you use the CGI save() and restore() methods a lot, you might be interested in the <CITE>Boulderio</CITE> file format. It's a way of transferring semi-strucured data from the standard output of one program to the standard input of the next. It comes with a simple Perl database, that позволяет вам сохранять и возвращать записи из базы данных DBM или DB_File, and is compatible with the format used by save() and restore(). Вы можете get more information on Boulderio from:
<PRE>  <A href="http://stein.cshl.org/software/boulder/">http://stein.cshl.org/software/boulder/</A></PRE>
<H3>A Script that Uses Self-Referencing URLs to Jump to Internal Links</H3>
<P>(Without losing form information).
<P>Many people have experienced problems with internal links on pages that have forms. Jumping around within the document causes the state of the form to be reset. A partial solution is to use the self_url() method to generate a link that preserves state information. This script illustrates how this works.
<PRE>
  #!/usr/local/bin/perl
  use CGI;

  $query = new CGI;

  # We generate a regular HTML file containing a very long list
  # and a popup menu that does nothing except to show that we
  # don't lose the state information.
  print $query-&gt;header;
  print $query-&gt;start_html("Internal Links Example");
  print "&lt;H1&gt;Internal Links Example&lt;/H1&gt;\n";

  print "&lt;A NAME=\"start\"&gt;&lt;/A&gt;\n"; # an anchor point at the top

  # pick a default начальное значение;
  $query-&gt;param('amenu','ФУ1') unless $query-&gt;param('amenu');

  print $query-&gt;startform;
  print $query-&gt;popup_menu('amenu',[('ФУ1'..'ФУ9')]);
  print $query-&gt;submit,$query-&gt;endform;

  # We create a long boring list for the purposes of illustration.
  $myself = $query-&gt;self_url;
  print "&lt;OL&gt;\n";
  for (1..100) {
    print qq{&lt;LI&gt;List item #$_&lt;A HREF="$myself#start"&gt;Jump to top&lt;/A&gt;\n};
  }
  print "&lt;/OL&gt;\n";

  print $query-&gt;end_html;
</PRE>
<H3>Multiple forms on the same page</H3>
<P>There's no particular trick to this. Just remember to close one form before you open another one. Вы можете reuse the same query object or create a new one. Either technique works.
<P>There is, однако, a problem with maintaining the states of multiple forms. Because the browser only sends your script the parameters from the form in which the submit button was pressed, the state of all the other forms will be lost. One way to get around this, suggested in this example, is to use hidden fields to pass as much information as possible regardless of which form the user submits.
<PRE>
  #!/usr/local/bin/perl
  use CGI;

  $query=new CGI;
  print $query-&gt;header;
  print $query-&gt;start_html('Множество форм');
  print "&lt;H1&gt;Множество форм&lt;/H1&gt;\n";

  # форма 1
  print "&lt;HR&gt;\n";
  print $query-&gt;startform;
  print $query-&gt;textfield('текст1'),$query-&gt;submit('submit1');
  print $query-&gt;hidden('текст2');  # pass information from the other form
  print $query-&gt;endform;
  print "&lt;HR&gt;\n";

  # форма 2
  print $query-&gt;startform;
  print $query-&gt;textfield('текст2'),$query-&gt;submit('submit2');
  print $query-&gt;hidden('текст1');  # pass information from the other form
  print $query-&gt;endform;
  print "&lt;HR&gt;\n";
  print $query-&gt;end_html;
</PRE>
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_subclassing">Subclassing CGI.pm</A></H2>
<P>CGI.pm uses various tricks to work in both an object-oriented and function-oriented fashion. It uses even more tricks to load quickly, despite the fact that it is a humungous module. These tricks may get in your way when you attempt to subclass CGI.pm.
<P>If you use standard subclassing techniques and restrict yourself to using CGI.pm and its subclasses in the object-oriented manner, you'll have no problems. Однако, если вы желаете to use the function-oriented calls with your subclass, follow this model: 
<PRE>
  package MySubclass;
  use vars qw(@ISA $VERSION);
  require CGI;
  @ISA = qw(CGI);
  $VERSION = 1.0;

  $CGI::DefaultClass = __PACKAGE__;
  $AutoloadClass = 'CGI';

  sub new {
    ....
  }
1;
</PRE>
<P>The first special trick is to set the CGI package variable $CGI::DefaultClass to the name of the module you are defining. Если вы используете Perl&nbsp;5.004 или выше, вы можете использовать специальный token "__PACKAGE__", чтобы возращать имя текущего модуля. Otherwise, just hard code the name of the module. This variable tells CGI what type of default object to create when called in the function-oriented manner.
<P>The second trick is to set the package variable $AutoloadClass to the string "CGI". This tells the CGI autoloader where to look for functions that are not defined. Если вы желаете to override CGI's autoloader, set this to the name of your own package.
<P>More information on extending CGI.pm can be found in my new book, <CITE>The Official Guide to CGI.pm</CITE>, which was published by John Wiley &amp; Sons in April 1998. Check out the book's <A href="http://www.wiley.com/compbooks/stein/">Web site</A>, which contains multiple useful coding examples.
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_mod_perl">Использование CGI.pm с mod_perl и FastCGI</A></H2>
<H3>FastCGI</H3>
<P><A href="http://www.fastcgi.com/">FastCGI</A> is a protocol invented by OpenMarket that markedly speeds up CGI scripts under certain circumstances. It works by opening up the script at server startup time and redirecting the script's IO to a Unix domain socket. Every time a new CGI request comes in, the script is passed new parameters to work on. This allows the script to perform all its time-consuming operations at initialization time (including loading CGI.pm!) and then respond quickly to new requests.
<P>FastCGI modules are available for the Apache and NCSA servers as well as for OpenMarket's own server. Чтобы use FastCGI with Perl you have to run a specially-modified version of the Perl interpreter. Precompiled Binaries and a patch kit are all available on OpenMarket's FastCGI web site.
<P>To use FastCGI with CGI.pm, change your scripts as follows:
<H4>Old Script</H4>
<PRE>
  #!/usr/local/bin/perl
  use CGI qw(:standard);

  print header,
      start_html("CGI Script"),
      h1("CGI Script"),
      "Not much to see here",
      hr,
      address(a({href=&gt;'/'},"home page"),
      end_html;
</PRE>
<H4>New Script</H4>
<PRE>
  #!/usr/local/fcgi/bin/perl
  use CGI::Fast qw(:standard);

  # Do time-consuming initialization up here.
  while (new CGI::Fast) {
    print header,
      start_html("CGI Script"),
      h1("CGI Script"),
      "Not much to see here",
      hr,
      address(a({href=&gt;'/'},"home page"),  
      end_html;
}
</PRE>
<P>That's all there is to it. The param() method, form-generation, HTML shortcuts, etc., all work the way you expect.
<H3>mod_perl</H3>
<P><A href="http://www.perl.com/CPAN/modules/Apache/">mod_perl</A> is a module for the Apache Web server that embeds a Perl interpreter into the Web server. It can be run in either of two modes:
<OL>
  <LI><P>Server launches a new Perl interpreter every time it needs to interpret a Perl script. This speeds CGI scripts significantly because there's no overhead   for launching a new Perl process.
  <LI><P>A "fast" mode in which the server launches your script at initialization time. Вы можете load all your favorite modules (like CGI.pm!) at initialization time, greatly speeding things up.
</OL>
<P>CGI.pm works with mod_perl, versions 0.95 и выше. If you use Perl&nbsp;5.003_93 or higher, your scripts should run without any modifications. Users with earlier versions of Perl should use the <CITE>CGI::Apache</CITE> module instead. This example shows the change needed:
<H4>Old Script</H4>
<PRE>
  #!/usr/local/bin/perl
  use CGI qw(:standard);

  print header,
      start_html("CGI Script"),
      h1("CGI Script"),
      "Not much to see here",
      hr,
      address(a({href=&gt;'/'},"home page"),  
      end_html;
</PRE>
<H4>New Script</H4>
<PRE>
  #!/usr/bin/perl
  use CGI::Apache qw(:standard);

  print header,
    start_html("CGI Script"),
    h1("CGI Script"),
    "Not much to see here",
    hr,
    address(a({href=&gt;'/'},"home page"),  
    end_html;
}
</PRE>
<P><STRONG>Important configuration note:</STRONG> When using CGI.pm with mod_perl be careful <STRONG>not</STRONG> to enable either the <TT>PerlSendHeader</TT> or <TT>PerlSetupEnv</TT> directives. This is handled automatically by CGI.pm and by Apache::Registry.
<P>mod_perl comes with a small wrapper library named <CITE>CGI::Switch</CITE> that selects dynamically between using CGI and CGI::Apache. This library is no longer needed. Однако users of CGI::Switch can continue to use it without risk. Note that the "simple" interface to the CGI.pm functions does not work with CGI::Switch. You'll have to use the object-oriented versions (or use the sfio version of Perl!)
<P>If you use CGI.pm in many of your mod_perl scripts, you may want to preload CGI.pm and its methods at server startup time. To do this, add the following line to httpd.conf:
<PRE>  PerlScript /home/httpd/conf/startup.pl</PRE>
<P>Create the file /home/httpd/conf/startup.pl and put in it all the modules you want to load. Include CGI.pm among them and call its <A href="#index_html_compile">compile()</A> method to precompile its autoloaded methods.
<PRE>
  #!/usr/local/bin/perl
  use CGI ();

  CGI-&gt;compile(':all');
</PRE>
<P>Change the path to the startup script according to your preferences.
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_migrating">Миграция из cgi-lib.pl</A></H2>
<P>To make it easier to convert older scripts that use cgi-lib.pl, CGI.pm provides a <STRONG>CGI::ReadParse()</STRONG> call that is compatible with cgi-lib.pl's <STRONG>ReadParse()</STRONG> subroutine.
<P>When you call ReadParse(), CGI.pm создает an associative array named <CODE>%in</CODE> that contains the named CGI parameters. Multi-valued parameters are separated by "\0" characters in exactly the same way cgi-lib.pl does it. The function result is the number of parameters parsed. Вы можете использовать this to determine whether the script is being called from a fill out form or not.
<P>To port an old script to CGI.pm, you have to make just two changes:
<H4>Old Script</H4>
<PRE>
  require "cgi-lib.pl";
  ReadParse();
  print "The price of your purchase is $in{price}.\n";
</PRE>
<H4>New Script</H4>
<PRE>
  use CGI qw(:cgi-lib);
  ReadParse();
  print "The price of your purchase is $in{price}.\n";
</PRE>
<P>Like cgi-lib's ReadParse, pass a variable <EM>glob</EM> чтобы use a different variable than the default "%in":
<PRE>
  ReadParse(*Q);
  @partners = split("\0",$Q{'golf_partners'});
</PRE>
<P>The associative array created by CGI::ReadParse() contains a special key 'CGI', which возвращает the CGI query object itself:
<PRE>
  ReadParse();
  $q = $in{CGI};
  print $q-&gt;textfield(-name=&gt;'wow',
                      -value=&gt;'does this really work?');
</PRE>
<P>This allows you to add the more interesting features of CGI.pm to your old scripts without rewriting them completely. As an added benefit, the <STRONG>%in</STRONG> variable is actually <CODE>tie()</CODE>'d to the CGI object. Changing the CGI object using <STRONG>param()</STRONG> will dynamically change <STRONG>%in</STRONG>, and vice-versa.
<P>cgi-lib.pl's <CODE>@in</CODE> and <CODE>$in</CODE> variables are <STRONG>not</STRONG> supported. In addition, the extended version of ReadParse() that allows you to spool uploaded files to disk is not available. You are strongly encouraged to use CGI.pm's file upload interface instead.
<P>Смотрите <A href="http://stein.cshl.org/WWW/software/CGI/cgi-lib_porting.html">cgi-lib_porting.html</A> за большими подробностями on porting cgi-lib.pl scripts to CGI.pm.
<HR>
<H2><A name="index_html_upload_caveats">Использование особенности для выгрузки файлов</A></H2>
<P>Особенность для выгрузки файлов работает не с каждой комбинацией браузера и сервера. Различные версии Netscape и Internet Explorer on the Macintosh, Unix and Windows platforms don't all seem to implement file uploading in exactly the same way. I've tried to make CGI.pm work with all versions on all platforms, but I keep getting reports from people of instances that break the file upload feature.
<P>Known problems include:
<OL>
  <LI><P>Large file uploads may fail when using SSL version 2.0. This affects the Netscape servers and possibly others that use the SSL library. I have received reports that WebSite Pro suffers from this problem. This is a documented bug in the Netscape implementation of SSL and not a problem with CGI.pm. 
  <LI><P>If you try to upload a <STRONG>directory</STRONG> path with Unix Netscape, the browser will hang until you hit the "stop" button. I haven't tried to   figure this one out since I think it's dumb of Netscape to allow this to happen at all.
  <LI><P>If you create the CGI object in one package (например, "main") and then obtain the filehandle in a different package (например, "фу"), the filehandle will be accessible through "main" but not "фу". Чтобы use the filehandle, try the following contortion:
  <PRE>
  $file = $query-&gt;param('file to upload');
  $file = "main::$file";
  ...
  </PRE>
  <P>I haven't found a way to determine the correct caller in this situation. I might add a readFile() method to CGI if this problem bothers enough people.
</OL>
<P>The main technical challenge of handling file uploads is that it potentially involves sending more data to the CGI script than the script can hold in main memory. For this reason CGI.pm создает temporary files in either the <CODE>/usr/tmp</CODE> or the <CODE>/tmp</CODE> directory. These temporary files have names like <CODE>CGItemp125421</CODE>, and should be deleted automatically.
<H3>Частые проблемы</H3>
<H4>Когда вы запускаете скрипт из командной строки, она говорит: "offline mode: enter name=value pairs on standard input". What do I do now?</H4>
<P>This is a prompt to enter some CGI parameters for the purposes of debugging. Вы можете now type in some parameters like this:
<PRE>
  first_name=Fred
  last_name=Flintstone
  city=Bedrock
</PRE>
<P>End the list by typing a control-D (or control-Z on DOS/Windows systems).
<P>If you want to run a CGI script from a script or batch file, and don't want this behavior, just pass it an empty parameter list like this:
<PRE>  my_script.pl ''</PRE>
<P>This will work too on Unix systems:
<PRE>  my_script.pl &lt;/dev/null</PRE>
<P>Another option is to use the "-no_debug" pragma when you "use" CGI.pm. This will suppress command-line debugging completely:
<PRE>  use CGI qw/:standard -no_debug/;</PRE>
<H4>Вы не можете вернуть имя выгруженного файла, используя метод param()</H4>
<P>Most likely the remote user isn't using version 2.0 (or higher) of Netscape. Alternatively she just isn't filling in the form completely.
<H4>When you accidentally try to upload a directory name, the browser hangs</H4>
<P>This seems to be a Netscape browser problem. It starts to upload junk to the script, then hangs. Вы можете abort by hitting the "stop" button.
<H4>Вы можете читать имя выгруженного файла, но не можете возвращать данные</H4>
<P>First check that you've told CGI.pm to use the new <A href="#index_html_multipart">multipart/form-data</A> scheme. If it still isn't working, there may be a problem with the temporary files that CGI.pm needs to create чтобы read in the (potentially very large) uploaded files. Internally, CGI.pm tries to create temporary files with names similar to <CODE>CGITemp123456</CODE> in a temporary directory. To find a suitable directory it first looks for <CODE>/usr/tmp</CODE> and then for <CODE>/tmp</CODE>. If it can't find either of these directories, it tries for the current directory, which is usually the same directory that the script resides in.
<P>If you're on a non-Unix system you may need to modify CGI.pm to point at a suitable temporary directory. This directory must be writable by the user ID under which the server runs (usually "nobody") and must have sufficient capacity to handle large file uploads. Open up CGI.pm, and find the line:
<PRE>
  package TempFile;

  foreach ('/usr/tmp','/tmp') { do {$TMPDIRECTORY = $_; last} if -d $_ &amp;&amp; -w _ }
</PRE>
<P>Modify the foreach() line to contain a series of one or more directories to store temporary files in.
<P>Alternatively, вы можете just skip the search entirely and force CGI.pm to store its temporary files in some logical location. Do this at the top of your script with a line like this one: $TempFile::TMPDIRECTORY='/WWW_ROOT';
<H4>On Windows Systems, the temporary file is never deleted, but hangs around in <CODE>\temp</CODE>, taking up space.</H4>
<P>Be sure to close the filehandle before your program exits. In fact, close the file as soon as you're finished with it, because the file will end up hanging around if the script later crashes.
<P>Unix users don't have this problem, because well designed operating systems make it possible to delete a file without closing it.
<H4>When you press the "back" button, the same page is loaded, not the previous one.</H4>
<P>Netscape&nbsp;2.0's history list gets confused when processing multipart forms. If the script generates different pages for the form and the results, hitting the "back" button doesn't always return you to the previous page; instead Netscape reloads the current page. This happens even if you don't use an upload file field in your form.
<P>A workaround for this is to use additional path information to trick Netscape into thinking that the form and the response have different URLs. I recommend giving each form a sequence number and bumping the sequence up by one each time the form is accessed:
<PRE>
  my($s) = $query-&gt;path_info=~/(\d+)/; # get sequence
  $s++;                                #bump it up
  # Trick Netscape into thinking it's loading a new script:
  print $q-&gt;start_multipart_form(-action=&gt;$q-&gt;script_name . "/$s");
</PRE>
<H4>Вы не можете найти the temporary file that CGI.pm создает</H4>
<P>You're encouraged to copy the data into your own file by reading from the file handle that CGI.pm provides you with. In the future there may be no temporary file at all, just a pipe. Однако, for now, if you really want to get at the temp file, вы можете вернуть its path using the <A href="#index_html_tmpfilename">tmpFileName()</A> method. Be sure to move the temporary file elsewhere in the file system if you don't want it to be automatically deleted when CGI.pm exits.
<HR>
<H2><A name="index_html_push">Server Push</A></H2>
<P>CGI.pm provides three simple functions for producing multipart documents of the type needed to implement server push. To import these into your namespace, you must import the ":push" set. You are also advised to put the script into NPH mode and to set $| to 1 to avoid buffering problems.
<P>Here is a simple script that demonstrates server push:
<PRE>
  #!/usr/local/bin/perl
  use CGI qw/:push -nph/;

  $| = 1;
  print multipart_init(-boundary=&gt;'----------------here we go!');
  while(1) {
    print multipart_start(-type=&gt;'text/plain'),
      "The current time is ",scalar(localtime),"\n",
      multipart_end;
    sleep 1;
  }
</PRE>
<P>This script initializes server push by calling <CITE>multipart_init()</CITE>. It then enters an infinite loop in which it begins a new multipart section by calling <CITE>multipart_start()</CITE>, prints the current local time, and ends a multipart section with <CITE>multipart_end()</CITE>. It then sleeps a second, and begins again.
<DL>
  <DT><P>multipart_init()
  <DD><PRE>  multipart_init(-boundary=&gt;$boundary);</PRE>
  <P>Initialize the multipart system. The -boundary argument specifies what MIME boundary string to use to separate parts of the document. If not provided, CGI.pm chooses a reasonable boundary for you.
  <DT><P>multipart_start()
  <DD><PRE>  multipart_start(-type=&gt;$type)</PRE>
  <P>Start a new part of the multipart document using the specified MIME type. If not specified, text/html is assumed.
  <DT><P>multipart_end()
  <DD><PRE>  multipart_end()</PRE>
  <P>End a part. You must remember to call multipart_end() once for each multipart_start().
</DL>
<P>Users interested in server push applications should also have a look at the CGI::Push module.
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_dos">Avoiding Denial of Service Attacks</A></H2>
<P>Потенциальная проблема с CGI.pm is that, by default, it attempts to process form POSTings no matter how large they are. Волный хакер could attack your site by sending a CGI script a huge POST of many megabytes. CGI.pm will attempt to read the entire POST into a variable, growing hugely in size until it runs out of memory. While the script attempts to allocate the memory the system may slow down dramatically. This is a form of denial of service attack.
<P>Another possible attack is for the remote user to force CGI.pm to accept a huge file upload. CGI.pm will accept the upload and store it in a temporary directory even if your script doesn't expect to receive an uploaded file. CGI.pm will delete the file automatically when it terminates, but in the meantime the remote user may have filled up the server's disk space, causing problems for other programs.
<P>The best way to avoid denial of service attacks is to limit the amount of memory, CPU time and disk space that CGI scripts can use. Some Web servers come with built-in facilities to accomplish this. In other cases, вы можете использовать the shell <EM>limit</EM> or <EM>ulimit</EM> commands to put ceilings on CGI resource usage.
<P>CGI.pm also has some simple built-in protections against denial of service attacks, but you must activate them before вы можете использовать them. These take the form of two global variables in the CGI name space:
<DL>
  <DT><P><STRONG><TT>$CGI::POST_MAX</TT></STRONG>
  <DD><P>If set to a non-negative integer, this variable puts a ceiling on the size of POSTings, in bytes. If CGI.pm detects a POST that is greater than the ceiling, it will immediately exit with an error message. This value will affect both ordinary POSTs and multipart POSTs, meaning that it limits the maximum size of file uploads as well. You should set this to a reasonably high value, such as 1 megabyte.
  <DT><P><STRONG><TT>$CGI::DISABLE_UPLOADS</TT></STRONG>
  <DD><P>If set to a non-zero value, this will disable file uploads completely. Other fill-out form values will work as usual.
</DL>
<P>Вы можете использовать these variables in either of two ways.
<OL>
  <LI><P>On a script-by-script basis. Set the variable at the top of the script, right after the "use" statement:
  <PRE>
  use CGI qw/:standard/;
  use CGI::Carp 'fatalsToBrowser';

  $CGI::POST_MAX=1024 * 100;  # max 100K posts
  $CGI::DISABLE_UPLOADS = 1;  # no uploads
  </PRE>
  <LI><P>Globally for all scripts. Open up CGI.pm, find the definitions for <TT>$POST_MAX</TT> and <TT>$DISABLE_UPLOADS</TT>, and set them to the desired values. You'll find them towards the top of the file in a subroutine named <TT>initialize_globals</TT>.
</OL>
<P>Since an attempt to send a POST larger than <TT>$POST_MAX</TT> bytes will cause a fatal error, you might want to use CGI::Carp to echo the fatal error message to the browser window as shown in the example above. Otherwise the remote user will see only a generic "Internal Server" error message. Смотрите the manual page for CGI::Carp за большими подробностями.
<P>An attempt to send a POST larger than $POST_MAX bytes will cause <B>param()</B> to return an empty CGI parameter list. Вы можете test for this event by checking <B>cgi_error()</B>, either after you create the CGI object or, if you are using the function-oriented interface, call <B>param()</B> for the first time. If the POST was intercepted, then cgi_error() will return the message "413 POST too large". 
<P>This error message is actually defined by the HTTP protocol, and is designed to be returned to the browser as the CGI script's status code. Например:
<PRE>
  $uploaded_file = param('upload');
  if(!$uploaded_file &amp;&amp; cgi_error()) {
    print header(-status=&gt;cgi_error());
    exit 0;
  }
</PRE>
<P>Some browsers may not know what to do with this status code. It may be better just to create an HTML page that warns the user of the problem.
<P><A href="#index_html_contents">Содержание</A>
<HR>
<H2><A name="index_html_non_unix">Использование CGI.pm на платформах не-Unix</A></H2>
<P>I don't have access to all the combinations of hardware and software that I really need to make sure that CGI.pm works consistently for all Web servers, so I rely heavily on helpful reports from users like yourself.
<P>There are a number of differences in file name and text processing conventions on different platforms. By default, CGI.pm is set up to work properly on a Unix (or Linux) system. During load, it will attempt to guess the correct operating system using the Config module. Currently it guesses correctly; однако if the operating system names change it may not work right. The main symptom will be that file upload does not work correctly. If this happens, find the place at the top of the script where the OS is defined, and uncomment the correct definition:
<PRE>
  # CHANGE THIS VARIABLE FOR YOUR OPERATING SYSTEM
  # $OS = 'UNIX';
  # $OS = 'MACINTOSH';
  # $OS = 'WINDOWS';
  # $OS = 'VMS';
</PRE>
<P>Other notes follow:
<H3><A name="index_html_windows">Windows NT</A></H3>
<P>CGI.pm works well with WebSite, the EMWACS server, Purveyor and the Microsoft IIS server. CGI.pm must be put in the Perl&nbsp;5 library directory, and all CGI scripts that use it should be placed in cgi-bin directory. You also need to associate the <CODE>.pl</CODE> suffix with Perl&nbsp;5 using the NT file manager (Website, Purveyor), or install the correct script mapping registry keys for IIS. There are two ports of Perl for Windows, one done by the ActiveWare company, and the other by Gurusamy Sarathy. I have only tested CGI.pm with the former. The home site for the ActiveWare port is:
<PRE>  <A href="http://www.activeware.com/">http://www.activeware.com/</A></PRE>
<P>The ActiveWare port comes in two parts. The first part is a standard standalone Perl interpreter. The second part is a small DLL library that implements a Perl ISAPI interface for IIS and other Web servers. As of build 307, the DLL library is <STRONG>seriously broken</STRONG>. It is seriously unreliable when used for any Perl CGI script, with or without CGI.pm. Symptoms include truncated CGI parameters, missing parameters, scrambled output, and failed file uploads. I strongly recommend that you use the standalone interpreter instead.
<P>The Microsoft IIS server is broken with respect to the handling of <A href="#index_html_path_info">additional path information</A>. If you use the DLL version of ActiveWare Perl, IIS will attempt to execute the additional path information as a script. If you use the external Perl interpreter, the additional path information may contain incorrect information. This is not a bug in CGI.pm.
<P>WebSite uses a slightly different cgi-bin directory structure than the standard. For this server, place the scripts in the <CODE>cgi-shl</CODE> directory. CGI.pm appears to work correctly in both the Windows95 and WindowsNT versions of WebSite.
<P>Old Netscape Communications Server technical notes recommended placing <CODE>perl.exe</CODE> in cgi-bin. This a very bad idea because it opens up a gaping security hole. Put a C <CODE>.exe</CODE> wrapper around the Perl script until such time as Netscape recognizes NT file manager associations, or provides a Perl-compatible DLL library for its servers.
<P>If you find that binary files get slightly larger when uploaded but that text files remain the same, then binary made is not correctly activated. Be sure to set the $OS variable to 'NT' or 'WINDOWS'. If you continue to have problems, make sure you're calling <STRONG>binmode()</STRONG> on the filehandle that you use to write the uploaded file to disk.
<H3>VMS</H3>
<P>I don't have access to a VMS machine, and I'm not sure whether file upload works correctly. Other features are known to work.
<H3>Macintosh</H3>
<P>Most CGI.pm features work with MacPerl version 5.0.6r1 or higher under the WebStar and MacHTTP servers. Чтобы install a Perl program to use with the Web, you'll need Matthias Nuuracher's PCGI extension, available at:
<PRE>  <A href="ftp://err.ethz.ch/pub/neeri/MacPerl/">ftp://err.ethz.ch/pub/neeri/MacPerl/</A></PRE>
<P>Known incompatibilities between CGI.pm and MacPerl include:
<OL>
  <LI><P>The Perl compiler will object to the use of -values in named parameters. Put single quotes around this parameter ('-values') or use the singular form ('-value') instead.
  <LI><P>File upload isn't working in my hands (Perl goes into an endless loop). Other people have gotten it to work.
</OL>
<HR>
<H2><A name="index_html_future">Отношение этой библиотеки к модулям CGI</A></H2>
<P>This library is maintained in parallel with the full featured CGI, URL, and HTML modules. I use this library to test out new ideas before incorporating them into the CGI hierarchy. I am continuing to maintain and improve this library чтобы satisfy people who are looking for an easy-to-use introduction to the world of CGI scripting.
<P>The CGI::* modules are being reworked to be interoperable with the excellent LWP modules. Stay tuned.
<P>Текущую версию CGI.pm можно найти на:
<PRE>  <A href="http://www.genome.wi.mit.edu/ftp/pub/software/WWW">http://www.genome.wi.mit.edu/ftp/pub/software/WWW</A></PRE>
<P>You are encouraged to look at these other Web-related modules:
<DL>
  <DT><P><A href="ftp://ftp.acoates.com/acoates/perl/">HTML.pm</A>
  <DD><P>A module that simplifies the creation of HTML documents programatically.
  <DT><P><A href="http://www.genome.wi.mit.edu/ftp/pub/software/WWW/CGIperl/">CGI::Base,CGI::Form,CGI::MiniSrv,CGI::Request and CGI::URI::URL</A>
  <DD><P>Modules for parsing script input, manipulating URLs, creating forms and even launching a miniature Web server.
  <DT><P><A href="http://www.ics.uci.edu/pub/websoft/libwww-perl/">libwww-perl</A>
  <DD><P>Modules for fetching Web resources from within Perl, writing Web robots, and much more.
</DL>
<P>You might also be interested in two packages for creating graphics on the fly:
<DL>
  <DT><P><A href="http://www.genome.wi.mit.edu/ftp/pub/software/WWW/GD.html">GD.html</A>
  <DD><P>A module for creating GIF images on the fly, using Tom Boutell's <A href="http://www.boutell.com/gd/">gd</A> graphics library.
  <DT><P><A href="http://www.genome.wi.mit.edu/ftp/pub/software/utilities/">qd.pl</A>
  <DD><P>A library for creating Macintosh PICT files on the fly (which can be converted to GIF or JPEG using NetPBM).
</DL>
<P>For a collection of CGI scripts of various levels of complexity, see the companion pages for my book <A href="http://www.genome.wi.mit.edu/WWW/">Как установить и поддерживать a World Wide Web Site</A>
<HR>
<H2><A name="index_html_distribution">Информация о распространении:</A></H2>
<P>Этот код охраняется авторскими правами 1995-1998 Линкольна Штейна. Он может свободно использоваться и модифицироваться, но я  do request that this copyright notice remain attached to the file. You may modify this module as you желаете, but if you redistribute a modified version, please attach a note listing the modifications you have made.
<HR>
<H2><A name="index_html_book">Книга по CGI.pm</A></H2>
<P><CITE>The Official Guide to CGI.pm</CITE>, by Lincoln Stein, is packed with tips and techniques for using the module, along with information about the module's internals that can't be found anywhere else. It is available on bookshelves now, or can be ordered from <A href="http://www.amazon.com/">amazon.com</A>. Also check the book's companion Web site at:
<BLOCKQUOTE>
  <A href="http://www.wiley.com/compbooks/stein/">http://www.wiley.com/compbooks/stein/</A>
</BLOCKQUOTE>
<HR>
<H2><A name="index_html_y2000">CGI.pm и проблема 2000&nbsp;года</A></H2>
<P>Версии CGI.pm до 2.36 страдали проблемой 2000&nbsp;года в управлении cookie. Сроки истечения cookie выражались, используя два разряда, как диктовалось тогда текущим протоколом Netscape cookie. Протокол cookie с тех пор был подчищен. По моему убеждению, версии CGI.pm 2.36 и выше согласованы с 2000&nbsp;годом.
<HR>
<H2><A name="index_html_mailingList">Почтовый список CGI-Perl</A></H2>
<P>The CGI Perl mailing list is defunct and is unlikely to be resurrected. Please address your questions to <A href="news:comp.infosystems.www.authoring.cgi">comp.infosystems.www.authoring.cgi</A> if they relate to the CGI protocol or the usage of CGI.pm <I>per gse</I>, or to <A href="news:comp.lang.perl.misc">comp.lang.perl.misc</A> for Perl <STRONG>language</STRONG> issues. Please read this documentation thoroughly, read the FAQs for these newsgroups and scan through previous messages before you make a posting. Respondents are not always friendly to people who neglect to do so!
<H2><A name="index_html_bugs">Отчеты об ошибках</A></H2>
<P>Отсылайте отчеты об ошибках и комментарии по адресу: <A href="mailto:lstein@cshl.org">lstein@cshl.org</A>.<BR>
Когда отправляете отчеты об ошибках, пожалуйста, снабжайте их следующей информацией:
<UL>
  <LI><P>версия CGI.pm (<CODE>perl -MCGI -e 'print $CGI::VERSION'</CODE>)
  <LI><P>версия Perl (<CODE>perl -v</CODE>)
  <LI><P>название и версия вашего Web-сервера
  <LI><P>название и версия операционной системы, которую вы используете
  <LI><P>если применимо, название и версия браузера, который вы используете
  <LI><P>короткий пробный скрипт, который воспроизводит проблему (30 строк или меньше)
</UL>
<P>Очень важно, чтобы я получил эту информацию, чтобы помочь вам.
<P><A href="#index_html_contents">Наверх к содержанию</A>
<HR>
<H2><A name="index_html_new">История редактуры</A></H2>
<H3>Версия 2.56</H3>
<OL>
  <LI><P>Fixed bugs in file upload introduced in version 2.55
  <LI><P>Fixed long-standing bug that prevented two files with identical names from being uploaded.
</OL>
<H3>Версия 2.55</H3>
<OL>
  <LI><P>Fixed cookie regression test so as not to produce an error.
  <LI><P>Fixed path_info() and self_url() to work correctly together when path_info() modified.
  <LI><P>Removed manify warnings from CGI::{Switch,Apache}.
</OL>
<H3>Версия 2.54</H3>
<OL>
  <LI><P>This will be the last release of the monolithic CGI.pm module. Later versions will be modularized and optimized.
  <LI><P>DOMAIN tag no longer added to cookies by default. This will break some versions of Internet Explorer, but will avoid breaking networks which use host tables without fully qualified domain names. For compatibility, please always add the -domain tag when creating cookies.
  <LI><P>Fixed escape() method so that +'s are treated correctly.
  <LI><P>Updated CGI::Pretty module.
</OL>
<H3>Версия 2.53</H3>
<OL>
  <LI><P>Forgot to upgrade regression tests before releasing 2.52. <B>NOTHING ELSE HAS CHANGED IN LIBRARY</B>
</OL>
<H3>Версия 2.52</H3>
<OL>
  <LI><P>Spurious newline in checkbox() routine removed. (courtesy John Essen)
  <LI><P>TEXTAREA linebreaks now respected in dump() routine. (courtesy John Essen)
  <LI><P>Patches for DOS ports (courtesy Robert Davies)
  <LI><P>Patches for VMS
  <LI><P>More fixes for cookie problems
  <LI><P>Fix CGI::Carp so that it doesn't affect eval{} blocks (courtesy Byron Brummer)
</OL>
<H3>Версия 2.51</H3>
<OL>
  <LI><P>Fixed problems with cookies not being remembered when sent to IE&nbsp;5.0 (and Netscape&nbsp;5.0 too?)
  <LI><P>Numerous HTML compliance problems in cgi_docs.html; fixed thanks to Michael Leahy
</OL>
<H3>Версия 2.50</H3>
<OL>
  <LI><P>Добавлен новый метод Vars(), чтобы возвращать все параметры as a tied hash.
  <LI><P>Untainted tainted tempfile name so that script doesn't fail on terminal unlink.
  <LI><P>Made picking of upload tempfile name more intelligent so that doesn't fail in case of name collision.
  <LI><P>Fixed handling of expire times when passed an absolute timestamp.
</OL>
<H3>Версия 2.49</H3>
<OL>
  <LI><P>Fixes for FastCGI (globals not getting reset)
  <LI><P>Fixed url() to correctly handle query string and path under MOD_PERL
</OL>
<H3>Версия 2.48</H3>
<OL>
  <LI><P>Reverted detection of MOD_PERL to avoid breaking PerlEX.
</OL>
<H3>Версия 2.47</H3>
<OL>
  <LI><P>Patch to fix file upload bug appearing in IE 3.01 for Macintosh/PowerPC.
  <LI><P>Replaced use of $ENV{SCRIPT_NAME} with $ENV{REQUEST_URI} when running under Apache, to fix self-referencing URIs.
  <LI><P>Fixed bug in escapeHTML() which caused certain constructs, such as CGI-&gt;image_button(), to fail.
  <LI><P>Fixed bug which caused strong('CGI') to fail. Be careful to use CGI::strong('CGI') and not CGI-&gt;strong('CGI'). The latter will produce confusing results.
  <LI><P>Added <B>upload()</B> function, as a preferred replacement for the "filehandle as string" feature.
  <LI><P>Added <B>cgi_error()</B> function.
  <LI><P>Rewrote file upload handling to return undef rather than dieing when an error is encountered. Be sure to call <B>cgi_error()</B> to find out what went wrong.
</OL>
<H3>Версия 2.46</H3>
<OL>
  <LI><P>Fix for failure of the "include" tests under mod_perl
  <LI><P>Added end_multipart_form to prevent failures during qw(-compile :all)
</OL>
<H3>Версия 2.45</H3>
<OL>
  <LI><P>Multiple small documentation fixes
  <LI><P><CITE>CGI::Pretty</CITE> didn't get into 2.44. Fixed now.
</OL>
<H3>Версия 2.44</H3>
<OL>
  <LI><P>Fixed file descriptor leak in upload function.
  <LI><P>Fixed bug in header() that prevented fields from containing double quotes.
  <LI><P>Added Brian Paulsen's <CITE>CGI::Pretty</CITE> package for pretty-printing output HTML.
  <LI><P>Removed CGI::Apache and CGI::Switch from the distribution.
  <LI><P>Generated start_* shortcuts so that start_table(), end_table(), start_ol(), end_ol(), and so forth now work (see the docs on how to enable this feature).
  <LI><P>Changed accept() to Accept(), sub() to Sub(). There's still a conflict with reset(), but this will break too many existing scripts!
</OL>
<H3>Версия 2.43</H3>
<OL>
  <LI><P>Fixed problem with "use strict" and file uploads (thanks to Peter Haworth)
  <LI><P>Fixed problem with not MSIE 3.01 for the power_mac not doing file uploads right.
  <LI><P>Fixed problem with file upload on IIS 4.0 when authorization in use.
  <LI><P>-content_type and '-content-type' can now be provided to header() as synonyms for -type.
  <LI><P>CGI::Carp now escapes the ampersand BEFORE escaping the &gt; and &lt; signs.
  <LI><P>Fixed "not an array reference" error when passing a hash reference to radio_group().
  <LI><P>Fixed non-removal of uploaded TMP files on NT platforms which occurs when server runs on non-C drive (thanks to Steve Kilbane for finding this one).
</OL>
<H3>Версия 2.42</H3>
<OL>
  <LI><P>Too many screams of anguish at измененом поведении url(). Is now back to its old behavior by default, with options to generate all the variants.
  <LI><P>Added regression tests. "make test" now works.
  <LI><P>Documentation fixes.
  <LI><P>Fixes for Macintosh uploads, but uploads STILL do not work pending changes to MacPerl.
</OL>
<H3>Версия 2.41</H3>
<OL>
  <LI><P>url() method now includes the path info. Use script_name() to get it without path info().
  <LI><P>Changed handling of empty attributes in HTML tag generation. Be warned! Use <TT><P>table({-border=&gt;undef})</TT> rather than <TT>table({-border=&gt;''})</TT>.
  <LI><P>Changes to allow uploaded filenames to be compared to other strings with "eq", "cmp" and "ne".
  <LI><P>Changes to allow CGI.pm to coexist more peacefully with ActiveState PerlEX.
  <LI><P>Changes to prevent exported variables from clashing when importing ":all" set in combination with cookies.
</OL>
<H3>Версия 2.40</H3>
<OL>
  <LI><P>CGI::Carp patched to work better with mod_perl (thanks to Chris Dean).
  <LI><P>Uploads of files whose names begin with numbers or the Windows \\UNC\shared\file nomenclature should no longer fail.
  <LI><P>The &lt;STYLE&gt; tag (for cascading style sheets) now generates the required TYPE attribute.
  <LI><P>Server push primitives added, thanks to Ed Jordan.
  <LI><P>Table and other HTML&nbsp;3 functions are now part of the :standard set.
  <LI><P>Small documentation fixes.
</OL>
<P><EM>TO DO:</EM> 
<OL>
  <LI><P>Do something about the DTD mess. The module should generate correct DTDs, or at least offer the programmer a way to specify the correct one.
  <LI><P>Split CGI.pm into CGI processing and HTML-generating modules.
  <LI><P>More robust file upload (?still not working on the Macintosh?).
  <LI><P>Bring in all the HTML&nbsp;4 functionality, particular the accessibility features.
</OL>
<H3>Версия 2.39</H3>
<OL>
  <LI><P>file uploads failing because of VMS patch; fixed.
  <LI><P>-dtd parameter was not being properly processed.
</OL>
<H3>Версия 2.38</H3>
<P>I finally got tired of all the 2.37 betas and released 2.38. The main difference between this version and the last 2.37 beta (2.37b30) are some fixes for VMS. This should allow file upload to work properly on all VMS Web servers.
<H3>Версия 2.37, various beta versions</H3>
<OL>
  <LI><P>Added a CGI::Cookie::parse() method for lucky mod_perl users.
  <LI><P>No longer need separate -values and -labels arguments for multi-valued form elements.
  <LI><P>Added better interface to raw cookies (fix courtesy Ken Fox, kfox@ford.com)
  <LI><P>Added param_fetch() function for direct access to parameter list.
  <LI><P>Fix to checkbox() to allow for multi-valued single checkboxes (weird problem).
  <LI><P>Added a compile() method for those who want to compile without importing.
  <LI><P>Documented the import pragmas a little better.
  <LI><P>Added a -compile switch to the use clause for the long-suffering mod_perl and Perl compiler users.
  <LI><P>Fixed initialization routines so that FileHandle and type globs work correctly (and hash initialization doesn't fail!).
  <LI><P>Better deletion of temporary files on NT systems.
  <LI><P>Added documentation on escape(), unescape(), unescapeHTML() and unescapeHTML() subroutines.
  <LI><P>Added documentation on creating subclasses.
  <LI><P>Fixed problem when calling $self-&gt;SUPER::foo() from inheriting subclasses.
  <LI><P>Fixed problem using filehandles from within subroutines.
  <LI><P>Fixed inability to use the string "CGI" as a parameter.
  <LI><P>Fixed exponentially growing $FILLUNIT bug
  <LI><P>Check for undef filehandle in read_from_client()
  <LI><P>Now requires the UNIVERSAL.pm module, present in Perl&nbsp;5.003_7 or higher.
  <LI><P>Fixed problem with uppercase-only parameters being ignored.
  <LI><P>Fixed vanishing cookie problem.
  <LI><P>Fixed warning in initialize_globals() under mod_perl.
  <LI><P>File uploads from Macintosh versions of MSIE should now work.
  <LI><P>Pragmas now preceded by dashes (-nph) rather than colons (:nph). Старый стиль is supported for backward compatability.
  <LI><P>Can now pass arguments to all functions using {} brackets, resolving historical inconsistencies.
  <LI><P>Removed autoloader warnings about absent MultipartBuffer::DESTROY.
  <LI><P>Fixed non-sticky checkbox() when -name used without -value.
  <LI><P>Hack to fix path_info() in IIS 2.0. Doesn't help with IIS 3.0.
  <LI><P>Parameter syntax for debugging from command line now more straightforward.
  <LI><P>Added $DISABLE_UPLOAD to disable file uploads.
  <LI><P>Added $POST_MAX to error out if POSTings exceed some ceiling.
  <LI><P>Fixed url_param(), which wasn't working at all.
  <LI><P>Fixed variable suicide problem in s///e expressions, where the autoloader was needed during evaluation.
  <LI><P>Removed excess spaces between elements of checkbox and radio groups
  <LI><P>Can now create "valueless" submit buttons
  <LI><P>Can now set path_info as well as read it.
  <LI><P>ReadParse() now возвращает a useful function result.
  <LI><P>import_names() now allows you to optionally clear out the namespace before importing (for mod_perl users)
  <LI><P>Made it possible to have a popup menu or radio button with a value of "0".
  <LI><P>link() changed to Link() to avoid overriding native link function.
  <LI><P>Takes advantage of mod_perl's register_cleanup() function to clear globals.
  <LI><P>&lt;LAYER&gt; and &lt;ILAYER&gt; added to :html3 functions.
  <LI><P>Fixed problems with private tempfiles and NT/IIS systems.
  <LI><P>No longer prints the DTD by default (I bet no one will complain).
  <LI><P>Allow underscores to replace internal hyphens in parameter names.
  <LI><P>CGI::Push supports heterogeneous MIME types and adjustable delays between pages.
  <LI><P>url_param() method added for retrieving URL parameters even when a fill-out form is POSTed.
  <LI><P>Got rid of warnings when radio_group() is called.
  <LI><P>Cookies now moved to their very own module.
  <LI><P>Fixed documentation bug in CGI::Fast.
  <LI><P>Added a :no_debug pragma to the import list.
</OL>
<H3>Версия 2.36</H3>
<OL>
  <LI><P>Expanded JavaScript functionality
  <LI><P>Preliminary поддержка каскадных таблиц стилей
  <LI><P>Security fixes for file uploads:
  <UL>
    <LI><P>Module will bail out if its temporary file already exists
    <LI><P>Temporary files can now be made completely private to avoid peeking by other users or CGI scripts.
  </UL>
  <LI><P><CITE>use CGI qw/:nph/</CITE> wasn't working correctly. Now it is.
  <LI><P>Cookie and HTTP date formats didn't meet spec. Thanks to Mark Fisher (fisherm@indy.tce.com) for catching and fixing this.
</OL> 
<H3>Версия 2.35</H3>
<OL>
  <LI><P>Robustified multipart file upload against incorrect syntax in POST.
  <LI><P>Fixed more problems with mod_perl.
  <LI><P>Added -noScript parameter to start_html().
  <LI><P>Documentation fixes.
</OL>
<H3>Версия 2.34</H3>
<OL>
  <LI><P>Stupid typo fix
</OL>
<H3>Версия 2.33</H3>
<OL>
  <LI><P>Fixed a warning about an undefined environment variable.
  <LI><P>Doug's patch for redirect() under mod_perl
  <LI><P>Partial fix for busted inheritence from CGI::Apache
  <LI><P>Documentation fixes.
</OL>
<H3>Версия 2.32</H3>
<OL>
  <LI><P>Improved support for Apache's mod_perl.
  <LI><P>Changes to better support inheritance.
  <LI><P>Support for OS/2.
</OL>
<H3>Версия 2.31</H3>
<OL>
  <LI><P>New <STRONG>uploadInfo()</STRONG> method to obtain header information from uploaded files.
  <LI><P><STRONG>cookie()</STRONG> without any arguments возвращает all the cookies passed to a script.
  <LI><P>Removed annoying warnings about $ENV{NPH} when running with the -w switch.
  <LI><P>Removed operator overloading throughout to make compatible with new versions of Perl.
  <LI><P><STRONG>-expires</STRONG> now implies the <STRONG>-date</STRONG> header, to avoid clock skew.
  <LI><P>WebSite passes cookies in $ENV{COOKIE} rather than $ENV{HTTP_COOKIE}. We now handle this, even though it's O'Reilly's fault.
  <LI><P>Tested successfully against new sfio I/O layer.
  <LI><P>Documentation fixes.
</OL>
<H3>Версия 2.30</H3>
<OL>
  <LI><P>Automatic detection of operating system at load time.
  <LI><P>Changed select() function to Select() чтобы avoid conflict with Perl built-in.
  <LI><P>Added Tr() as an alternative to TR(); some people think it looks better that way.
  <LI><P>Fixed problem with autoloading of MultipartBuffer::DESTROY code.
  <LI><P>Added the following methods:
  <UL>
    <LI><P>virtual_host()
    <LI><P>server_software()
  </UL>
  <LI><P>Automatic NPH mode when running under Microsoft IIS server.
</OL>
<H3>Версия 2.29</H3>
<OL>
  <LI><P>Fixed cookie bugs
  <LI><P>Fixed problems that cropped up when useNamedParameters was set to 1.
  <LI><P>Prevent CGI::Carp::fatalsToBrowser() from crapping out when encountering a die() within an eval().
  <LI><P>Fixed problems with filehandle initializers.
</OL>
<H3>Версия 2.28</H3>
<OL>
  <LI><P>Added support for NPH scripts; also fixes problems with Microsoft IIS.
  <LI><P>Fixed a problem with checkbox() values not being correctly saved and restored.
  <LI><P>Fixed a bug in which CGI objects created with empty string initializers took on default values from earlier CGI objects.
  <LI><P>Documentation fixes.
</OL>
<H3>Версия 2.27</H3>
<OL>
  <LI><P>Small but important bug fix: the automatic capitalization of tag attributes was accidentally capitalizing the VALUES as well as the ATTRIBUTE names (oops).
</OL>
<H3>Версия 2.26</H3>
<OL>
  <LI><P>Изменено поведение методов scrolling_list(), checkbox() и checkbox_group() таким образом, что defaults are honored correctly. The "fix" causes endform() to generate additional &lt;INPUT TYPE="HIDDEN"&gt; tags -- don't be surpised.
  <LI><P>Fixed bug involving the detection of the SSL protocol.
  <LI><P>Fixed documentation error in position of the -meta argument in start_html().
  <LI><P>HTML shortcuts now generate tags in ALL UPPERCASE.
  <LI><P>start_html() now generates correct SGML header:
  <PRE>  &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"&gt;</PRE>
  <LI><P>CGI::Carp no longer fails "use strict refs" pragma.
</OL>
<H3>Версия 2.25</H3>
<OL>
  <LI><P>Fixed bug that caused bad redirection on destination URLs with arguments.
  <LI><P>Fixed bug involving use_named_parameters() followed by start_multipart_form()
  <LI><P>Fixed bug that caused incorrect determination of binmode for Macintosh.
  <LI><P>Spelling fixes on documentation.
</OL>
<H3>Версия 2.24</H3>
<OL>
  <LI><P>Fixed bug that caused generation of lousy HTML for some form elements
  <LI><P>Fixed uploading bug in Windows NT
  <LI><P>Some code cleanup (not enough)
</OL>
<H3>Версия 2.23</H3>
<OL>
  <LI><P>Fixed an obscure bug that caused scripts to fail mysteriously.
  <LI><P>Fixed auto-caching bug.
  <LI><P>Fixed bug that prevented HTML shortcuts from passing taint checks.
  <LI><P>Fixed some -w warning problems.
</OL>
<H3>Версия 2.22</H3>
<OL>
  <LI><P>New CGI::Fast module for use with FastCGI protocol. Смотрите pod documentation for details.
  <LI><P>Fixed problems with inheritance and autoloading.
  <LI><P>Added TR() (&lt;tr&gt;) and PARAM() (&lt;param&gt;) methods to list of exported HTML tag-generating functions.
  <LI><P>Moved all CGI-related I/O to a bottleneck method so that this can be overridden more easily in mod_perl (thanks to Doug MacEachern).
  <LI><P>put() method as substitute for print() for use in mod_perl.
  <LI><P>Fixed crash in tmpFileName() method.
  <LI><P>Added tmpFileName(), startform() and endform() to export list.
  <LI><P>Fixed problems with attributes in HTML shortcuts.
  <LI><P>Functions that don't actually need access to the CGI object now no longer generate a default one. May speed things up slightly.
  <LI><P>Aesthetic improvements in generated HTML.
  <LI><P>New examples.
</OL>
<H3>Версия 2.21</H3>
<OL>
  <LI><P>Added the <CITE>-meta</CITE> argument to <CITE>start_html()</CITE>.
  <LI><P>Fixed hidden fields (again).
  <LI><P>Radio_group() and checkbox_group() now return an appropriate scalar value when called in a scalar context, rather than returning a numeric value!
  <LI><P>Cleaned up the formatting of form elements to avoid unesthetic extra spaces within the attributes.
  <LI><P>HTML elements now correctly include the closing tag when parameters are present but null: em('')
  <LI><P>Added password_field() to the export list.
</OL>
<H3>Версия 2.20</H3>
<OL>
  <LI><P>Dumped the SelfLoader because of problems with running with taint checks and rolled my own. Performance is now significantly improved.
  <LI><P>Added HTML shortcuts.
  <LI><P><CITE>import()</CITE> now adheres to the Perl module conventions, allowing CGI.pm to import any or all method names into the user's name space.
  <LI><P>Added the ability to initialize CGI objects from strings and associative arrays.
  <LI><P>Made it possible to initialize CGI objects with filehandle references rather than filehandle strings.
  <LI><P>Added the delete_all() and append() methods.
  <LI><P>CGI objects correctly initialize from filehandles on NT/95 systems now.
  <LI><P>Fixed the problem with binary file uploads on NT/95 systems.
  <LI><P>Fixed bug in redirect().
  <LI><P>Added '-Window-target' parameter to redirect().
  <LI><P>Fixed import_names() so that parameter names containing funny characters work.
  <LI><P>Broke the unfortunate connection between cookie and CGI parameter name space.
  <LI><P>Fixed problems with hidden fields whose values are 0.
  <LI><P>Cleaned up the documentation somewhat.
</OL>
<H3>Версия 2.19</H3>
<OL>
  <LI><P>Added cookie() support routines.
  <LI><P>Added -expires parameter to header().
  <LI><P>Added cgi-lib.pl compatability mode.
  <LI><P>Made the module more configurable for different operating systems.
  <LI><P>Fixed a dumb bug in JavaScript button() method.
</OL>
<H3>Версия 2.18</H3>
<OL>
  <LI><P>Fixed a bug that corrects a hang that occurs on some platforms when processing file uploads. Unfortunately this disables the check for bad Netscape uploads.
  <LI><P>Fixed bizarre problem involving the inability to process uploaded files that begin with a non alphabetic character in the file name.
  <LI><P>Fixed a bug in the hidden fields involving the -override directive being ignored when scalar defaults were passed.
  <LI><P>Added documentation on how to disable the SelfLoader features.
</OL>
<H3>Версия 2.17</H3>
<OL>
  <LI><P>Added support for the SelfLoader module.
  <LI><P>Added oodles of JavaScript support routines.
  <LI><P>Fixed bad bug in query_string() method that caused some parameters to be silently dropped.
  <LI><P>Robustified file upload code to handle premature termination by the client.
  <LI><P>Exported temporary file names on file upload.
  <LI><P>Removed spurious "uninitialized variable" warnings that appeared when running under 5.002.
  <LI><P>Added the Carp.pm library to the standard distribution.
  <LI><P>Fixed a number of errors in this documentation, and probably added a few more.
  <LI><P>Checkbox_group() and radio_group() now return the buttons as arrays, so that вы можете incorporate the individual buttons into specialized tables.
  <LI><P>Added the '-nolabels' option to checkbox_group() and radio_group(). Probably should be added to all the other HTML-generating routines.
  <LI><P>Added the url() method to recover the URL without the entire query string appended.
  <LI><P>Added request_method() to list of environment variables available.
  <LI><P>Would you believe it? Fixed hidden fields <EM>again</EM>!
</OL>
<H3>Версия 2.16</H3>
<OL>
  <LI><P>Fixed hidden fields <EM>yet again</EM>.
  <LI><P>Fixed subtle problems in the file upload method that caused intermittent failures (thanks to Keven Hendrick for this one).
  <LI><P>Made file upload more robust in the face of bizarre behavior by the Macintosh and Windows Netscape clients.
  <LI><P>Moved the POD documentation to the bottom of the module at the request of Stephen Dahmen.
  <LI><P>Added the -xbase parameter to the start_html() method, also at the request of Stephen Dahmen.
  <LI><P>Added JavaScript form buttons at Stephen's request. I'm not sure how to use this Netscape extension correctly, однако, so for now the form() method is in the module as an undocumented feature. Use at your own risk!
</OL>
<H3>Версия 2.15</H3>
<OL>
  <LI><P>Added the <B>-override</B> parameter to all field-generating methods.
  <LI><P>Documented the <CODE>user_name()</CODE> and <CODE>remote_user()</CODE> methods.
  <LI><P>Fixed bugs that prevented empty strings from being recognized as valid textfield contents.
  <LI><P>Documented the use of framesets and added a frameset example.
</OL>
<H3>Версия 2.14</H3>
<P>This was an internal experimental version that was never released.
<H3>Версия 2.13</H3>
<OL>
  <LI><P>Fixed a bug that interfered with the value "0" being entered into text fields.
</OL>
<H3>Версия 2.01</H3>
<OL>
  <LI><P>Added -rows and -columns to the radio and checkbox groups. No doubt this will cause much grief because it seems to promise a level of meta-organization that it doesn't actually provide.
  <LI><P>Fixed a bug in the redirect() method -- it was not truly HTTP/1.0 compliant.
</OL>
<H3>Версия 2.0</H3>
<P>The changes seemed to touch every line of code, so I decided to bump up the major version number. 
<OL>
  <LI><P>Поддержка <A href="#index_html_named_param">стиля вызовов методов с именованными параметрами.</A> This turns out to be a big win for extending CGI.pm when Netscape adds new HTML "features".
  <LI><P>Изменено поведение of hidden fields back to the correct "sticky" behavior.
  <A href="#index_html_hidden_fields_warning">This is going to break some programs,</A> but it is for the best in the long run.
  <LI><P>Netscape&nbsp;2.0b2 broke the file upload feature. CGI.pm now handles both 2.0b1 and 2.0b2-style uploading. It will probably break again in 2.0b3.
  <LI><P>There were still problems with library being unable to distinguish between a form being loaded for the first time, and a subsequent loading with all fields blank. We now forcibly create a default name for the Submit button (if not provided) so that there's always at least one parameter.
  <LI><P>More workarounds to prevent annoying spurious warning messages when run under the -w switch. -w is seriously broken in Perl&nbsp;5.001!
</OL>
<H3>Версия 1.57</H3>
<OL>
  <LI><P>Support for the Netscape&nbsp;2.0 "File upload" field.
  <LI><P>The handling of defaults for selected items in списках с возможностью прокрутки и multiple checkboxes is now consistent.
</OL>
<H3>Версия 1.56</H3>
<OL>
  <LI><P>Created true "pod" documentation for the module.
  <LI><P>Cleaned up the code to avoid many of the spurious "use of uninitialized variable" warnings when running with the -w switch.
  <LI><P>Added the <CODE>autoEscape()</CODE> method.
  <LI><P>Added string interpolation of the CGI object.
  <LI><P>Added the ability to pass additional parameters to the &lt;BODY&gt; tag.
  <LI><P>Added the ability to specify the status code in the HTTP header.
</OL>
<H3>Bug fixes in version 1.55</H3>
<OL>
  <LI><P>Every time self_url() was called, the parameter list would grow. This was a bad "feature".
  <LI><P>Documented the fact that вы можете pass "-" to radio_group() чтобы prevent any button from being highlighted by default.
</OL>
<H3>Bug fixes in version 1.54</H3>
<OL>
  <LI><P>The user_agent() method is now documented;
  <LI><P>A potential security hole in import() is now plugged.
  <LI><P>Changed name of import() to import_names() for compatability with CGI:: modules.
</OL>
<H3>Bug fixes in version 1.53</H3>
<OL>
  <LI><P>Fixed several typos in the code that were causing the following subroutines to fail in some circumstances
  <OL>
    <LI><P>checkbox()
    <LI><P>hidden()
  </OL>
  <LI><P>No features added
</OL>
<H3>New features added in version 1.52</H3>
<OL>
  <LI><P>Added backslashing, quotation marks, and other shell-style escape sequences to the parameters passed in during debugging off-line.
  <LI><P>Changed the way that the hidden() method works so that the default value always overrides the current one.
  <LI><P>Improved the handling of sticky values in forms. It's now less likely that sticky values will get stuck.
  <LI><P>If you call server_name(), script_name() and several other methods when running offline, the methods now create "dummy" values to work with.
</OL>
<H3>Bugs fixed in version 1.51</H3>
<OL>
  <LI><P>param() when called without arguments was returning an array of length 1 even when there were no parameters to be had. Bad bug! Bad!
  <LI><P>The HTML code generated would break if input fields contained the forbidden characters "&gt;&lt; or &amp;. Вы можете now use these characters freely.
</OL>
<H3>New features added in version 1.50</H3>
<OL>
  <LI><P>import() method allows all the parameters to be imported into a namespace in one fell swoop.
  <LI><P>Parameters are now returned in the same order in which they were defined.
</OL>
<H3>Bugs fixed in version 1.45</H3>
<OL>
  <LI><P>delete() method didn't work correctly. This is now fixed.
  <LI><P>reset() method didn't allow you to set the name of the button. Fixed.
</OL>
<H3>Bugs fixed in version 1.44</H3>
<OL>
  <LI><P>self_url() didn't include the path information. This is now fixed.
</OL>
<H3>New features added in version 1.43</H3>
<OL>
  <LI><P>Added the delete() method.
</OL>
<H3>New features added in version 1.42</H3>
<OL>
  <LI><P>The image_button() method to create clickable images.
  <LI><P>A few bug fixes involving forms embedded in &lt;PRE&gt; blocks.
</OL>
<H3>New features added in version 1.4</H3>
<OL>
  <LI><P>New header shortcut methods
  <UL>
    <LI><P>redirect() to create HTTP redirection messages.
    <LI><P>start_html() to create the HTML title, complete with the recommended &lt;LINK&gt; tag that no one ever remembers to include.
    <LI><P>end_html() for completeness' sake.
  </UL>
  <LI><P>A new save() method that allows you to write out the state of an script to a file or pipe.
  <LI><P>An improved version of the new() method that allows you to restore the state of a script from a file or pipe. With (2) this gives you dump and restore capabilities! (Wow, вы можете put a "121,931 customers served" banner at the bottom of your pages!)
  <LI><P>A self_url() method that allows you to create state-maintaining hypertext links. В дополнение к allowing you to maintain the state of your scripts between invocations, this lets you work around a problem that some browsers have when jumping to internal links in a document that contains a form -- the form information gets lost.
  <LI><P>The user-visible labels в выключателях, переключателях, popup menus и списках с возможностью прокрутки have now been decoupled from the values sent to your CGI script. Your script can know a checkbox by the name of "cb1" while the user knows it by a more descriptive name. I've also added some parameters that were 
  missing from the text fields, such as MAXLENGTH.
  <LI><P>A whole bunch of methods have been added to get at environment variables involved in user verification and other obscure features.
</OL>
<H3>Bug fixes</H3>
<OL>
  <LI><P>The problems with the hidden fields have (I hope at last) been fixed.
  <LI><P>Вы можете create multiple query objects and they will all be initialized correctly. This simplifies the creation of multiple forms on one page.
  <LI><P>The URL unescaping code works correctly now.
</OL>
<P><A href="#index_html_contents">Содержание</A> 
<HR>
<ADDRESS>
  Линкольн Д. Штейн, lstein@cshl.org<BR>
  <A href="http://www.cshl.org/">Cold Spring Harbor Laboratory</A>
</ADDRESS>
<hr>

<!--#include virtual="/footer.raw"-->

</body></html>