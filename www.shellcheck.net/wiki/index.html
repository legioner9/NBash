<h1>ShellCheck Wiki Sitemap</h1>
The wiki is maintained <a href="https://github.com/koalaman/shellcheck/wiki">on GitHub</a>. This page is primarily for the benefit of search engines.
<ul>
<li><a href='Azure-Pipelines.html'>Azure-Pipelines</a> &ndash; </li>
<li><a href='Buildkite.html'>Buildkite</a> &ndash; </li>
<li><a href='CentOS6.html'>CentOS6</a> &ndash; </li>
<li><a href='Checks.html'>Checks</a> &ndash; Finding documentation for a check</li>
<li><a href='CircleCI.html'>CircleCI</a> &ndash; </li>
<li><a href='Contrib.html'>Contrib</a> &ndash; </li>
<li><a href='DevGuide.html'>DevGuide</a> &ndash; ShellCheck Dev Guide</li>
<li><a href='Directive.html'>Directive</a> &ndash; ShellCheck directives</li>
<li><a href='GitHub-Actions.html'>GitHub-Actions</a> &ndash; Differential ShellCheck</li>
<li><a href='GitLab-CI.html'>GitLab-CI</a> &ndash; </li>
<li><a href='Home.html'>Home</a> &ndash; Welcome to the ShellCheck wiki! </li>
<li><a href='Ignore.html'>Ignore</a> &ndash; Ignoring errors</li>
<li><a href='Integration.html'>Integration</a> &ndash; Integrating with ShellCheck</li>
<li><a href='JUnit.html'>JUnit</a> &ndash; Getting JUnit XML from ShellCheck</li>
<li><a href='JUnit2text.html'>JUnit2text</a> &ndash; </li>
<li><a href='More-Installation-Guides.html'>More-Installation-Guides</a> &ndash; Installing ShellCheck on CentOS 6 / RHEL6</li>
<li><a href='Optional.html'>Optional</a> &ndash; Optional checks</li>
<li><a href='Parser-error.html'>Parser-error</a> &ndash; </li>
<li><a href='Phabricator.html'>Phabricator</a> &ndash; Installation</li>
<li><a href='Recursiveness.html'>Recursiveness</a> &ndash; </li>
<li><a href='SC1000.html'>SC1000</a> &ndash; `$` is not used specially and should therefore be escaped.</li>
<li><a href='SC1001.html'>SC1001</a> &ndash; This `\o` will be a regular 'o' in this context.</li>
<li><a href='SC1003.html'>SC1003</a> &ndash; Want to escape a single quote? `echo 'This is how it'\''s done'`.</li>
<li><a href='SC1004.html'>SC1004</a> &ndash; This backslash+linefeed is literal. Break outside single quotes if you just want to break the line.</li>
<li><a href='SC1007.html'>SC1007</a> &ndash; Remove space after `=` if trying to assign a value (or for empty string, use `var=''` ... ).</li>
<li><a href='SC1008.html'>SC1008</a> &ndash; This shebang was unrecognized. ShellCheck only supports sh/bash/dash/ksh. Add a 'shell' directive to specify.</li>
<li><a href='SC1009.html'>SC1009</a> &ndash; The mentioned parser error was in ...</li>
<li><a href='SC1010.html'>SC1010</a> &ndash; Use semicolon or linefeed before `done` (or quote to make it literal).</li>
<li><a href='SC1011.html'>SC1011</a> &ndash; This apostrophe terminated the single quoted string!</li>
<li><a href='SC1012.html'>SC1012</a> &ndash; `\t` is just literal `t` here. For tab, use `"$(printf '\t')"` instead.</li>
<li><a href='SC1014.html'>SC1014</a> &ndash; Use `if cmd; then ..` to check exit code, or `if [ "$(cmd)" = .. ]` to check output.</li>
<li><a href='SC1015.html'>SC1015</a> &ndash; This is a unicode double quote. Delete and retype it.</li>
<li><a href='SC1016.html'>SC1016</a> &ndash; This is a Unicode single quote. Delete and retype it.</li>
<li><a href='SC1017.html'>SC1017</a> &ndash; Literal carriage return. Run script through `tr -d '\r'` .</li>
<li><a href='SC1018.html'>SC1018</a> &ndash; This is a unicode non-breaking space. Delete it and retype as space.</li>
<li><a href='SC1019.html'>SC1019</a> &ndash; Expected this to be an argument to the unary condition.</li>
<li><a href='SC1020.html'>SC1020</a> &ndash; You need a space before the `]` or `]]`</li>
<li><a href='SC1026.html'>SC1026</a> &ndash; If grouping expressions inside `[[..]]`, use `( .. )`.</li>
<li><a href='SC1027.html'>SC1027</a> &ndash; Expected another argument for this operator.</li>
<li><a href='SC1028.html'>SC1028</a> &ndash; In `[..]` you have to escape `\( \)` or preferably combine `[..]` expressions.</li>
<li><a href='SC1029.html'>SC1029</a> &ndash; In `[[..]]` you shouldn't escape `(` or `)`.</li>
<li><a href='SC1033.html'>SC1033</a> &ndash; Test expression was opened with double `[[` but closed with single `]`. Make sure they match.</li>
<li><a href='SC1034.html'>SC1034</a> &ndash; Test expression was opened with double `[` but closed with single `]]`. Make sure they match.</li>
<li><a href='SC1035.html'>SC1035</a> &ndash; You need a space here</li>
<li><a href='SC1036.html'>SC1036</a> &ndash; `(` is invalid here. Did you forget to escape it?</li>
<li><a href='SC1037.html'>SC1037</a> &ndash; Braces are required for positionals over 9, e.g. `${10}`.</li>
<li><a href='SC1038.html'>SC1038</a> &ndash; Shells are space sensitive. Use `< <(cmd)`, not `<<(cmd)`.</li>
<li><a href='SC1039.html'>SC1039</a> &ndash; Remove indentation before end token (or use `<<-` and indent with tabs).</li>
<li><a href='SC1040.html'>SC1040</a> &ndash; When using `<<-`, you can only indent with tabs.</li>
<li><a href='SC1041.html'>SC1041</a> &ndash; Found `eof` further down, but not on a separate line.</li>
<li><a href='SC1043.html'>SC1043</a> &ndash; Found EOF further down, but with wrong casing.</li>
<li><a href='SC1044.html'>SC1044</a> &ndash; Couldn't find end token `EOF` in the here document.</li>
<li><a href='SC1045.html'>SC1045</a> &ndash; It's not `foo &; bar`, just `foo & bar`.</li>
<li><a href='SC1046.html'>SC1046</a> &ndash; Couldn't find `fi` for this `if`.</li>
<li><a href='SC1047.html'>SC1047</a> &ndash; Expected `fi` matching previously mentioned `if`.</li>
<li><a href='SC1048.html'>SC1048</a> &ndash; Can't have empty then clauses (use `true` as a no-op).</li>
<li><a href='SC1049.html'>SC1049</a> &ndash; Did you forget the `then` for this `if`?</li>
<li><a href='SC1050.html'>SC1050</a> &ndash; Expected `then`.</li>
<li><a href='SC1051.html'>SC1051</a> &ndash; Semicolons directly after `then` are not allowed. Just remove it.</li>
<li><a href='SC1052.html'>SC1052</a> &ndash; Semicolons directly after `then` are not allowed. Just remove it.</li>
<li><a href='SC1053.html'>SC1053</a> &ndash; Semicolons directly after `else` are not allowed. Just remove it.</li>
<li><a href='SC1054.html'>SC1054</a> &ndash; You need a space after the `{`.</li>
<li><a href='SC1055.html'>SC1055</a> &ndash; You need at least one command here. Use `true;` as a no-op.</li>
<li><a href='SC1056.html'>SC1056</a> &ndash; Expected a `}`. If you have one, try a `;` or `\n` in front of it.</li>
<li><a href='SC1057.html'>SC1057</a> &ndash; Did you forget the `do` for this loop?</li>
<li><a href='SC1058.html'>SC1058</a> &ndash; Expected `do`.</li>
<li><a href='SC1059.html'>SC1059</a> &ndash; Semicolon is not allowed directly after `do`. You can just delete it.</li>
<li><a href='SC1060.html'>SC1060</a> &ndash; Can't have empty do clauses (use `true` as a no-op)</li>
<li><a href='SC1061.html'>SC1061</a> &ndash; Couldn't find `done` for this `do`.</li>
<li><a href='SC1062.html'>SC1062</a> &ndash; Expected `done` matching previously mentioned `do`.</li>
<li><a href='SC1063.html'>SC1063</a> &ndash; You need a line feed or semicolon before the `do`.</li>
<li><a href='SC1064.html'>SC1064</a> &ndash; Expected a `{` to open the function definition.</li>
<li><a href='SC1065.html'>SC1065</a> &ndash; Trying to declare parameters? Don't. Use `()` and refer to params as `$1`, `$2`, ..</li>
<li><a href='SC1066.html'>SC1066</a> &ndash; Don't use `$` on the left side of assignments.</li>
<li><a href='SC1067.html'>SC1067</a> &ndash; For indirection, use arrays, `declare "var$n=value"`, or (for sh) `read`/`eval`</li>
<li><a href='SC1068.html'>SC1068</a> &ndash; Don't put spaces around the `=` in assignments.</li>
<li><a href='SC1069.html'>SC1069</a> &ndash; You need a space before the `[`.</li>
<li><a href='SC1070.html'>SC1070</a> &ndash; Parsing stopped here. Mismatched keywords or invalid parentheses?</li>
<li><a href='SC1071.html'>SC1071</a> &ndash; ShellCheck only supports sh/bash/dash/ksh scripts. Sorry!</li>
<li><a href='SC1072.html'>SC1072</a> &ndash; Unexpected ..</li>
<li><a href='SC1073.html'>SC1073</a> &ndash; Couldn't parse this (thing). Fix to allow more checks.</li>
<li><a href='SC1074.html'>SC1074</a> &ndash; Did you forget the `;;` after the previous case item?</li>
<li><a href='SC1075.html'>SC1075</a> &ndash; Use `elif` instead of `else if`.</li>
<li><a href='SC1076.html'>SC1076</a> &ndash; Trying to do math? Use e.g. `[ $((i/2+7)) -ge 18 ]`.</li>
<li><a href='SC1077.html'>SC1077</a> &ndash; For command expansion, the tick should slant left (`` ` `` vs `Â´`).</li>
<li><a href='SC1078.html'>SC1078</a> &ndash; Did you forget to close this double quoted string?</li>
<li><a href='SC1079.html'>SC1079</a> &ndash; This is actually an end quote, but due to next char it looks suspect.</li>
<li><a href='SC1080.html'>SC1080</a> &ndash; You need `\` before line feeds to break lines in `[ ]`.</li>
<li><a href='SC1081.html'>SC1081</a> &ndash; Scripts are case-sensitive. Use `if`, not `If`.</li>
<li><a href='SC1082.html'>SC1082</a> &ndash; This file has a UTF-8 BOM. Remove it with: `LC_CTYPE=C sed '1s/^...//' < yourscript`.</li>
<li><a href='SC1083.html'>SC1083</a> &ndash; This `{`/`}` is literal. Check if `;` is missing or quote the expression.</li>
<li><a href='SC1084.html'>SC1084</a> &ndash; Use `#!`, not `!#`, for the shebang.</li>
<li><a href='SC1086.html'>SC1086</a> &ndash; Don't use `$` on the iterator name in for loops.</li>
<li><a href='SC1087.html'>SC1087</a> &ndash; Use braces when expanding arrays, e.g. `${array[idx]}` (or `${var}[..` to quiet).</li>
<li><a href='SC1088.html'>SC1088</a> &ndash; Parsing stopped here. Invalid use of parentheses?</li>
<li><a href='SC1089.html'>SC1089</a> &ndash; Parsing stopped here. Is this keyword correctly matched up?</li>
<li><a href='SC1090.html'>SC1090</a> &ndash; Can't follow non-constant source. Use a directive to specify location</li>
<li><a href='SC1091.html'>SC1091</a> &ndash; Not following: (error message here)</li>
<li><a href='SC1092.html'>SC1092</a> &ndash; Stopping at 100 `source` frames :O</li>
<li><a href='SC1094.html'>SC1094</a> &ndash; Parsing of sourced file failed. Ignoring it.</li>
<li><a href='SC1095.html'>SC1095</a> &ndash; You need a space or linefeed between the function name and body.</li>
<li><a href='SC1097.html'>SC1097</a> &ndash; Unexpected `==`. For assignment, use `=`. For comparison, use `[`/`[[`.</li>
<li><a href='SC1098.html'>SC1098</a> &ndash; Quote/escape special characters when using `eval`, e.g. `eval "a=(b)"`.</li>
<li><a href='SC1099.html'>SC1099</a> &ndash; You need a space before the `#`.</li>
<li><a href='SC1100.html'>SC1100</a> &ndash; This is a unicode dash. Delete and retype as ASCII minus.</li>
<li><a href='SC1101.html'>SC1101</a> &ndash; Delete trailing spaces after `\` to break line (or use quotes for literal space).</li>
<li><a href='SC1102.html'>SC1102</a> &ndash; Shells disambiguate `$((` differently or not at all. For `$(command substitution)`, add space after `$(` . For `$((arithmetics))`, fix parsing errors.</li>
<li><a href='SC1103.html'>SC1103</a> &ndash; This shell type is unknown. Use e.g. `sh` or `bash`.</li>
<li><a href='SC1104.html'>SC1104</a> &ndash; Use `#!`, not just `!`, for the shebang.</li>
<li><a href='SC1105.html'>SC1105</a> &ndash; Shells disambiguate `((` differently or not at all. If the first `(` should start a subshell, add a space after it.</li>
<li><a href='SC1106.html'>SC1106</a> &ndash; In arithmetic contexts, use `<` instead of `-lt`</li>
<li><a href='SC1107.html'>SC1107</a> &ndash; This directive is unknown. It will be ignored.</li>
<li><a href='SC1108.html'>SC1108</a> &ndash; You need a space before and after the `=` .</li>
<li><a href='SC1109.html'>SC1109</a> &ndash; This is an unquoted HTML entity. Replace with corresponding character.</li>
<li><a href='SC1110.html'>SC1110</a> &ndash; This is a unicode quote. Delete and retype it (or quote to make literal).</li>
<li><a href='SC1111.html'>SC1111</a> &ndash; This is a unicode quote. Delete and retype it (or ignore/singlequote for literal).</li>
<li><a href='SC1112.html'>SC1112</a> &ndash; This is a unicode quote. Delete and retype it (or ignore/doublequote for literal).</li>
<li><a href='SC1113.html'>SC1113</a> &ndash; Use `#!`, not just `#`, for the shebang.</li>
<li><a href='SC1114.html'>SC1114</a> &ndash; Remove leading spaces before the shebang.</li>
<li><a href='SC1115.html'>SC1115</a> &ndash; Remove spaces between `#` and `!` in the shebang.</li>
<li><a href='SC1116.html'>SC1116</a> &ndash; Missing `$` on a `$((..))` expression? (or use `( (` for arrays).</li>
<li><a href='SC1117.html'>SC1117</a> &ndash; Backslash is literal in `"\n"`. Prefer explicit escaping: `"\\n"`.</li>
<li><a href='SC1118.html'>SC1118</a> &ndash; Delete whitespace after the here-doc end token.</li>
<li><a href='SC1119.html'>SC1119</a> &ndash; Add a linefeed between end token and terminating `)`.</li>
<li><a href='SC1120.html'>SC1120</a> &ndash; No comments allowed after here-doc token. Comment the next line instead.</li>
<li><a href='SC1121.html'>SC1121</a> &ndash; Add `;`/`&` terminators (and other syntax) on the line with the `<<`, not here.</li>
<li><a href='SC1122.html'>SC1122</a> &ndash; Nothing allowed after end token. To continue a command, put it on the line with the `<<`.</li>
<li><a href='SC1123.html'>SC1123</a> &ndash; ShellCheck directives are only valid in front of complete compound commands, like `if`, not e.g. individual `elif` branches.</li>
<li><a href='SC1124.html'>SC1124</a> &ndash; ShellCheck directives are only valid in front of complete commands like `case` statements, not individual case branches.</li>
<li><a href='SC1125.html'>SC1125</a> &ndash; Invalid `key=value` pair in directive</li>
<li><a href='SC1126.html'>SC1126</a> &ndash; Place shellcheck directives before commands, not after.</li>
<li><a href='SC1127.html'>SC1127</a> &ndash; Was this intended as a comment? Use `#` in sh.</li>
<li><a href='SC1128.html'>SC1128</a> &ndash; The shebang must be on the first line. Delete blanks and move comments.</li>
<li><a href='SC1129.html'>SC1129</a> &ndash; You need a space before the `!`.</li>
<li><a href='SC1130.html'>SC1130</a> &ndash; You need a space before the :.</li>
<li><a href='SC1131.html'>SC1131</a> &ndash; Use `elif` to start another branch.</li>
<li><a href='SC1132.html'>SC1132</a> &ndash; This `&` terminates the command. Escape it or add space after `&` to silence.</li>
<li><a href='SC1133.html'>SC1133</a> &ndash; Unexpected start of line. If breaking lines, `|`/`||`/`&&` should be at the end of the previous one.</li>
<li><a href='SC1134.html'>SC1134</a> &ndash; </li>
<li><a href='SC1135.html'>SC1135</a> &ndash; Prefer escape over ending quote to make `$` literal. Instead of `"It costs $"5`, use `"It costs \$5"`</li>
<li><a href='SC1136.html'>SC1136</a> &ndash; Unexpected characters after terminating `]`. Missing semicolon/linefeed?</li>
<li><a href='SC1137.html'>SC1137</a> &ndash; Missing second `(` to start arithmetic for ((;;)) loop</li>
<li><a href='SC1138.html'>SC1138</a> &ndash; Shells are space sensitive. Use `< <(cmd)`, not `<< (cmd)`.</li>
<li><a href='SC1139.html'>SC1139</a> &ndash; Use `||` instead of `-o` between test commands.</li>
<li><a href='SC1140.html'>SC1140</a> &ndash; Unexpected parameters after condition. Missing `&&`/`||`, or bad expression?</li>
<li><a href='SC1141.html'>SC1141</a> &ndash; Unexpected tokens after compound command. Bad redirection or missing `;`/`&&`/`||`/`|`?</li>
<li><a href='SC1142.html'>SC1142</a> &ndash; Use `done < <(cmd)` to redirect from process substitution (currently missing one `<`).</li>
<li><a href='SC1143.html'>SC1143</a> &ndash; This backslash is part of a comment and does not continue the line.</li>
<li><a href='SC1144.html'>SC1144</a> &ndash; `external-sources` can only be enabled in .shellcheckrc, not in individual files.</li>
<li><a href='SC1145.html'>SC1145</a> &ndash; Unknown `external-sources` value. Expected `true`/`false`.</li>
<li><a href='SC2000.html'>SC2000</a> &ndash; See if you can use `${#variable}` instead</li>
<li><a href='SC2001.html'>SC2001</a> &ndash; See if you can use `${variable//search/replace}` instead.</li>
<li><a href='SC2002.html'>SC2002</a> &ndash; Useless cat. Consider `cmd < file | ..` or `cmd file | ..` instead.</li>
<li><a href='SC2003.html'>SC2003</a> &ndash; expr is antiquated. Consider rewriting this using `$((..))`, `${}` or `[[  ]]`.</li>
<li><a href='SC2004.html'>SC2004</a> &ndash; `$`/`${}` is unnecessary on arithmetic variables.</li>
<li><a href='SC2005.html'>SC2005</a> &ndash; </li>
<li><a href='SC2007.html'>SC2007</a> &ndash; Use `$((..))` instead of deprecated `$[..]`.</li>
<li><a href='SC2008.html'>SC2008</a> &ndash; `echo` doesn't read from stdin, are you sure you should be piping to it?</li>
<li><a href='SC2009.html'>SC2009</a> &ndash; Consider using `pgrep` instead of grepping `ps` output.</li>
<li><a href='SC2010.html'>SC2010</a> &ndash; Don't use `ls | grep`. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.</li>
<li><a href='SC2011.html'>SC2011</a> &ndash; Use `find -print0` or `find -exec` to better handle non-alphanumeric filenames.</li>
<li><a href='SC2012.html'>SC2012</a> &ndash; Use `find` instead of `ls` to better handle non-alphanumeric filenames.</li>
<li><a href='SC2013.html'>SC2013</a> &ndash; To read lines rather than words, pipe/redirect to a `while read` loop.</li>
<li><a href='SC2014.html'>SC2014</a> &ndash; This will expand once before find runs, not per file found.</li>
<li><a href='SC2015.html'>SC2015</a> &ndash; Note that `A && B || C` is not if-then-else. C may run when A is true.</li>
<li><a href='SC2016.html'>SC2016</a> &ndash; Expressions don't expand in single quotes, use double quotes for that.</li>
<li><a href='SC2017.html'>SC2017</a> &ndash; Increase precision by replacing `a/b*c` with `a*c/b`.</li>
<li><a href='SC2018.html'>SC2018</a> &ndash; Use `[:lower:]` to support accents and foreign alphabets.</li>
<li><a href='SC2019.html'>SC2019</a> &ndash; Use `[:upper:]` to support accents and foreign alphabets.</li>
<li><a href='SC2020.html'>SC2020</a> &ndash; `tr` replaces sets of chars, not words (mentioned due to duplicates).</li>
<li><a href='SC2021.html'>SC2021</a> &ndash; Don't use `[]` around ranges in `tr`, it replaces literal square brackets.</li>
<li><a href='SC2022.html'>SC2022</a> &ndash; Note that unlike globs, `o*` here matches `ooo` but not `oscar`.</li>
<li><a href='SC2023.html'>SC2023</a> &ndash; The shell may override `time` as seen in man time(1). Use `command time ..` for that one.</li>
<li><a href='SC2024.html'>SC2024</a> &ndash; `sudo` doesn't affect redirects. Use `..| sudo tee file`</li>
<li><a href='SC2025.html'>SC2025</a> &ndash; Make sure all escape sequences are enclosed in `\[..\]` to prevent line wrapping issues.</li>
<li><a href='SC2026.html'>SC2026</a> &ndash; This word is outside of quotes. Did you intend to `'nest '"'single quotes'"'` instead'?</li>
<li><a href='SC2027.html'>SC2027</a> &ndash; The surrounding quotes actually unquote this. Remove or escape them.</li>
<li><a href='SC2028.html'>SC2028</a> &ndash; `echo` won't expand escape sequences. Consider `printf`.</li>
<li><a href='SC2029.html'>SC2029</a> &ndash; Note that, unescaped, this expands on the client side.</li>
<li><a href='SC2030.html'>SC2030</a> &ndash; Modification of var is local (to subshell caused by pipeline).</li>
<li><a href='SC2031.html'>SC2031</a> &ndash; var was modified in a subshell. That change might be lost.</li>
<li><a href='SC2032.html'>SC2032</a> &ndash; This function can't be invoked via su on line 42.</li>
<li><a href='SC2033.html'>SC2033</a> &ndash; Shell functions can't be passed to external commands. Use separate script or sh -c.</li>
<li><a href='SC2034.html'>SC2034</a> &ndash; foo appears unused. Verify it or export it.</li>
<li><a href='SC2035.html'>SC2035</a> &ndash; Use `./*glob*` or `-- *glob*` so names with dashes won't become options.</li>
<li><a href='SC2036.html'>SC2036</a> &ndash; If you wanted to assign the output of the pipeline, use `a=$(b | c)` .</li>
<li><a href='SC2037.html'>SC2037</a> &ndash; To assign the output of a command, use `var=$(cmd)` .</li>
<li><a href='SC2038.html'>SC2038</a> &ndash; Use `-print0`/`-0` or `find -exec +` to allow for non-alphanumeric filenames.</li>
<li><a href='SC2039.html'>SC2039</a> &ndash; In POSIX sh, *something* is undefined.</li>
<li><a href='SC2040.html'>SC2040</a> &ndash; `#!/bin/sh` was specified, so ____ is not supported, even when sh is actually bash.</li>
<li><a href='SC2041.html'>SC2041</a> &ndash; This is a literal string. To run as a command, use `$(..)` instead of `'..'` .</li>
<li><a href='SC2042.html'>SC2042</a> &ndash; Use spaces, not commas, to separate loop elements.</li>
<li><a href='SC2043.html'>SC2043</a> &ndash; This loop will only ever run once for a constant value. Did you perhaps mean to loop over `dir/*`, `$var` or `$(cmd)`?</li>
<li><a href='SC2044.html'>SC2044</a> &ndash; For loops over find output are fragile. Use `find -exec` or a `while read` loop.</li>
<li><a href='SC2045.html'>SC2045</a> &ndash; Iterating over ls output is fragile. Use globs.</li>
<li><a href='SC2046.html'>SC2046</a> &ndash; Quote this to prevent word splitting.</li>
<li><a href='SC2048.html'>SC2048</a> &ndash; Use `"$@"` (with quotes) to prevent whitespace problems.</li>
<li><a href='SC2049.html'>SC2049</a> &ndash; `=~` is for regex, but this looks like a glob. Use `=` instead.</li>
<li><a href='SC2050.html'>SC2050</a> &ndash; This expression is constant. Did you forget the `$` on a variable?</li>
<li><a href='SC2051.html'>SC2051</a> &ndash; Bash doesn't support variables in brace range expansions.</li>
<li><a href='SC2053.html'>SC2053</a> &ndash; Quote the rhs of `=` in `[[ ]]` to prevent glob matching.</li>
<li><a href='SC2054.html'>SC2054</a> &ndash; Use spaces, not commas, to separate array elements.</li>
<li><a href='SC2055.html'>SC2055</a> &ndash; You probably wanted `&&` here, otherwise it's always true.</li>
<li><a href='SC2056.html'>SC2056</a> &ndash; You probably wanted `&&` here</li>
<li><a href='SC2057.html'>SC2057</a> &ndash; Unknown binary operator.</li>
<li><a href='SC2058.html'>SC2058</a> &ndash; Unknown unary operator.</li>
<li><a href='SC2059.html'>SC2059</a> &ndash; Don't use variables in the `printf` format string. Use `printf "..%s.." "$foo"`.</li>
<li><a href='SC2060.html'>SC2060</a> &ndash; Quote parameters to tr to prevent glob expansion.</li>
<li><a href='SC2061.html'>SC2061</a> &ndash; Quote the parameter to `-name` so the shell won't interpret it.</li>
<li><a href='SC2062.html'>SC2062</a> &ndash; Quote the grep pattern so the shell won't interpret it.</li>
<li><a href='SC2063.html'>SC2063</a> &ndash; Grep uses regex, but this looks like a glob.</li>
<li><a href='SC2064.html'>SC2064</a> &ndash; Use single quotes, otherwise this expands now rather than when signalled.</li>
<li><a href='SC2065.html'>SC2065</a> &ndash; This is interpreted as a shell file redirection, not a comparison.</li>
<li><a href='SC2066.html'>SC2066</a> &ndash; Since you double quoted this, it will not word split, and the loop will only run once.</li>
<li><a href='SC2067.html'>SC2067</a> &ndash; Missing `;` or `+` terminating `-exec`. You can't use `|`/`||`/`&&`, and `;` has to be a separate, quoted argument.</li>
<li><a href='SC2068.html'>SC2068</a> &ndash; Double quote array expansions to avoid re-splitting elements.</li>
<li><a href='SC2069.html'>SC2069</a> &ndash; To redirect stdout+stderr, `2>&1` must be last (or use `{ cmd > file; } 2>&1` to clarify).</li>
<li><a href='SC2070.html'>SC2070</a> &ndash; `-n` doesn't work with unquoted arguments. Quote or use `[[ ]]`.</li>
<li><a href='SC2071.html'>SC2071</a> &ndash; `>` is for string comparisons. Use `-gt` instead.</li>
<li><a href='SC2072.html'>SC2072</a> &ndash; Decimals are not supported. Either use integers only, or use `bc` or `awk` to compare.</li>
<li><a href='SC2073.html'>SC2073</a> &ndash; Escape `\<` to prevent it redirecting (or switch to `[[ .. ]]`).</li>
<li><a href='SC2074.html'>SC2074</a> &ndash; Can't use `=~` in `[ ]`. Use `[[..]]` instead.</li>
<li><a href='SC2075.html'>SC2075</a> &ndash; Escaping `\<` is required in `[..]`, but invalid in `[[..]]`</li>
<li><a href='SC2076.html'>SC2076</a> &ndash; Don't quote rhs of `=~`, it'll match literally rather than as a regex.</li>
<li><a href='SC2077.html'>SC2077</a> &ndash; You need spaces around the comparison operator.</li>
<li><a href='SC2078.html'>SC2078</a> &ndash; This expression is constant. Did you forget a `$` somewhere?</li>
<li><a href='SC2079.html'>SC2079</a> &ndash; `(( ))` doesn't support decimals. Use `bc` or `awk`.</li>
<li><a href='SC2080.html'>SC2080</a> &ndash; Numbers with leading 0 are considered octal.</li>
<li><a href='SC2081.html'>SC2081</a> &ndash; `[ .. ]` can't match globs. Use `[[ .. ]]` or grep.</li>
<li><a href='SC2082.html'>SC2082</a> &ndash; To expand via indirection, use `name="foo$n"; echo "${!name}"`.</li>
<li><a href='SC2083.html'>SC2083</a> &ndash; Don't add spaces after the slash in `./file`.</li>
<li><a href='SC2084.html'>SC2084</a> &ndash; Remove `$` or use `_=$((expr))` to avoid executing output.</li>
<li><a href='SC2086.html'>SC2086</a> &ndash; Double quote to prevent globbing and word splitting.</li>
<li><a href='SC2087.html'>SC2087</a> &ndash; Quote `EOF` to make here document expansions happen on the server side rather than on the client.</li>
<li><a href='SC2088.html'>SC2088</a> &ndash; Tilde does not expand in quotes. Use `$HOME`.</li>
<li><a href='SC2089.html'>SC2089</a> &ndash; Quotes/backslashes will be treated literally. Use an array.</li>
<li><a href='SC2090.html'>SC2090</a> &ndash; Quotes/backslashes in this variable will not be respected.</li>
<li><a href='SC2091.html'>SC2091</a> &ndash; Remove surrounding `$()` to avoid executing output (or use `eval` if intentional).</li>
<li><a href='SC2092.html'>SC2092</a> &ndash; Remove backticks to avoid executing output.</li>
<li><a href='SC2093.html'>SC2093</a> &ndash; Remove `exec ` if script should continue after this command.</li>
<li><a href='SC2094.html'>SC2094</a> &ndash; Make sure not to read and write the same file in the same pipeline.</li>
<li><a href='SC2095.html'>SC2095</a> &ndash; Use `ssh -n` to prevent ssh from swallowing stdin.</li>
<li><a href='SC2096.html'>SC2096</a> &ndash; On most OS, shebangs can only specify a single parameter.</li>
<li><a href='SC2097.html'>SC2097</a> &ndash; This assignment is only seen by the forked process.</li>
<li><a href='SC2098.html'>SC2098</a> &ndash; This expansion will not see the mentioned assignment.</li>
<li><a href='SC2099.html'>SC2099</a> &ndash; Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`</li>
<li><a href='SC2100.html'>SC2100</a> &ndash; Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`</li>
<li><a href='SC2101.html'>SC2101</a> &ndash; Named class needs outer `[]`, e.g. `[[:digit:]]`.</li>
<li><a href='SC2102.html'>SC2102</a> &ndash; Ranges can only match single chars (mentioned due to duplicates).</li>
<li><a href='SC2103.html'>SC2103</a> &ndash; Use a `( subshell )` to avoid having to `cd` back.</li>
<li><a href='SC2104.html'>SC2104</a> &ndash; In functions, use `return` instead of `break`.</li>
<li><a href='SC2105.html'>SC2105</a> &ndash; `break` is only valid in loops</li>
<li><a href='SC2106.html'>SC2106</a> &ndash; This only exits the subshell caused by the pipeline.</li>
<li><a href='SC2107.html'>SC2107</a> &ndash; Instead of `[ a && b ]`, use `[ a ] && [ b ]`.</li>
<li><a href='SC2108.html'>SC2108</a> &ndash; In `[[..]]`, use `&&` instead of `-a`.</li>
<li><a href='SC2109.html'>SC2109</a> &ndash; Instead of `[ a || b ]`, use `[ a ] || [ b ]`.</li>
<li><a href='SC2110.html'>SC2110</a> &ndash; In `[[..]]`, use `||` instead of `-o`.</li>
<li><a href='SC2111.html'>SC2111</a> &ndash; ksh does not allow `function` keyword and `()` at the same time.</li>
<li><a href='SC2112.html'>SC2112</a> &ndash; `function` keyword is non-standard. Delete it.</li>
<li><a href='SC2113.html'>SC2113</a> &ndash; `function` keyword is non-standard. Use `foo()` instead of `function foo`.</li>
<li><a href='SC2114.html'>SC2114</a> &ndash; Warning: deletes a system directory.</li>
<li><a href='SC2115.html'>SC2115</a> &ndash; Use `"${var:?}"` to ensure this never expands to `/*` .</li>
<li><a href='SC2116.html'>SC2116</a> &ndash; Useless echo? Instead of `cmd $(echo foo)`, just use `cmd foo`.</li>
<li><a href='SC2117.html'>SC2117</a> &ndash; To run commands as another user, use `su -c` or `sudo`.</li>
<li><a href='SC2118.html'>SC2118</a> &ndash; Ksh does not support `|&`. Use `2>&1 |`</li>
<li><a href='SC2119.html'>SC2119</a> &ndash; Use `foo "$@"` if function's `$1` should mean script's `$1`.</li>
<li><a href='SC2120.html'>SC2120</a> &ndash; foo references arguments, but none are ever passed.</li>
<li><a href='SC2121.html'>SC2121</a> &ndash; To assign a variable, use just `var=value`, not `set ..`.</li>
<li><a href='SC2122.html'>SC2122</a> &ndash; `>=` is not a valid operator. Use `! a < b` instead.</li>
<li><a href='SC2123.html'>SC2123</a> &ndash; `PATH` is the shell search path. Use another name.</li>
<li><a href='SC2124.html'>SC2124</a> &ndash; Assigning an array to a string! Assign as array, or use `*` instead of `@` to concatenate.</li>
<li><a href='SC2125.html'>SC2125</a> &ndash; Brace expansions and globs are literal in assignments. Quote it or use an array.</li>
<li><a href='SC2126.html'>SC2126</a> &ndash; Consider using `grep -c` instead of `grep | wc`</li>
<li><a href='SC2127.html'>SC2127</a> &ndash; To use `${ ..; }`, specify `#!/usr/bin/env ksh`.</li>
<li><a href='SC2128.html'>SC2128</a> &ndash; Expanding an array without an index only gives the element in the index 0.</li>
<li><a href='SC2129.html'>SC2129</a> &ndash; Consider using `{ cmd1; cmd2; } >> file` instead of individual redirects.</li>
<li><a href='SC2130.html'>SC2130</a> &ndash; `-eq` is for integer comparisons. Use `=` instead.</li>
<li><a href='SC2139.html'>SC2139</a> &ndash; This expands when defined, not when used. Consider escaping.</li>
<li><a href='SC2140.html'>SC2140</a> &ndash; Word is of the form `"A"B"C"` (B indicated). Did you mean `"ABC"` or `"A\\"B\\"C"`?</li>
<li><a href='SC2141.html'>SC2141</a> &ndash; Did you mean `IFS=$'\t'` ?</li>
<li><a href='SC2142.html'>SC2142</a> &ndash; Aliases can't use positional parameters. Use a function.</li>
<li><a href='SC2143.html'>SC2143</a> &ndash; Use `grep -q` instead of comparing output with `[ -n .. ]`.</li>
<li><a href='SC2144.html'>SC2144</a> &ndash; `-e` doesn't work with globs. Use a `for` loop.</li>
<li><a href='SC2145.html'>SC2145</a> &ndash; Argument mixes string and array. Use `*` or separate argument.</li>
<li><a href='SC2146.html'>SC2146</a> &ndash; This action ignores everything before the `-o`. Use `\( \)` to group.</li>
<li><a href='SC2147.html'>SC2147</a> &ndash; Literal tilde in PATH works poorly across programs.</li>
<li><a href='SC2148.html'>SC2148</a> &ndash; Tips depend on target shell and yours is unknown. Add a shebang.</li>
<li><a href='SC2149.html'>SC2149</a> &ndash; Remove `$`/`${}` for numeric index, or escape it for string.</li>
<li><a href='SC2150.html'>SC2150</a> &ndash; `-exec` does not automatically invoke a shell. Use `-exec sh -c ..` for that.</li>
<li><a href='SC2151.html'>SC2151</a> &ndash; Only one integer 0-255 can be returned. Use stdout for other data.</li>
<li><a href='SC2152.html'>SC2152</a> &ndash; Can only return 0-255. Other data should be written to stdout.</li>
<li><a href='SC2153.html'>SC2153</a> &ndash; Possible Misspelling: MYVARIABLE may not be assigned. Did you mean MY_VARIABLE?</li>
<li><a href='SC2154.html'>SC2154</a> &ndash; var is referenced but not assigned.</li>
<li><a href='SC2155.html'>SC2155</a> &ndash; Declare and assign separately to avoid masking return values.</li>
<li><a href='SC2156.html'>SC2156</a> &ndash; Injecting filenames is fragile and insecure. Use parameters.</li>
<li><a href='SC2157.html'>SC2157</a> &ndash; Argument to implicit `-n` is always true due to literal strings.</li>
<li><a href='SC2158.html'>SC2158</a> &ndash; `[ false ]` is true. Remove the brackets</li>
<li><a href='SC2159.html'>SC2159</a> &ndash; `[ 0 ]` is true. Use `false` instead.</li>
<li><a href='SC2160.html'>SC2160</a> &ndash; Instead of `[ true ]`, just use `true`.</li>
<li><a href='SC2161.html'>SC2161</a> &ndash; Instead of `[ 1 ]`, use `true`.</li>
<li><a href='SC2162.html'>SC2162</a> &ndash; `read` without `-r` will mangle backslashes.</li>
<li><a href='SC2163.html'>SC2163</a> &ndash; This does not export `FOO`. Remove `$`/`${}` for that, or use `${var?}` to quiet.</li>
<li><a href='SC2164.html'>SC2164</a> &ndash; Use `cd ... || exit` in case `cd` fails.</li>
<li><a href='SC2165.html'>SC2165</a> &ndash; This nested loop overrides the index variable of its parent.</li>
<li><a href='SC2166.html'>SC2166</a> &ndash; Prefer `[ p ] && [ q ]` as `[ p -a q ]` is not well defined.</li>
<li><a href='SC2167.html'>SC2167</a> &ndash; This parent loop has its index variable overridden.</li>
<li><a href='SC2168.html'>SC2168</a> &ndash; `local` is only valid in functions.</li>
<li><a href='SC2169.html'>SC2169</a> &ndash; In dash, *something* is not supported.</li>
<li><a href='SC2170.html'>SC2170</a> &ndash; Invalid number for `-eq`. Use `=` to compare as string (or use `$var` to expand as a variable).</li>
<li><a href='SC2171.html'>SC2171</a> &ndash; Found trailing `]` outside test. Add missing `[` or quote if intentional.</li>
<li><a href='SC2172.html'>SC2172</a> &ndash; Trapping signals by number is not well defined. Prefer signal names.</li>
<li><a href='SC2173.html'>SC2173</a> &ndash; SIGKILL/SIGSTOP can not be trapped.</li>
<li><a href='SC2174.html'>SC2174</a> &ndash; When used with `-p`, `-m` only applies to the deepest directory.</li>
<li><a href='SC2175.html'>SC2175</a> &ndash; Quote this invalid brace expansion since it should be passed literally to eval</li>
<li><a href='SC2176.html'>SC2176</a> &ndash; `time` is undefined for pipelines. time single stage or `bash -c` instead.</li>
<li><a href='SC2177.html'>SC2177</a> &ndash; `time` is undefined for compound commands, use `time sh -c` instead.</li>
<li><a href='SC2178.html'>SC2178</a> &ndash; Variable was used as an array but is now assigned a string.</li>
<li><a href='SC2179.html'>SC2179</a> &ndash; Use `array+=("item")` to append items to an array.</li>
<li><a href='SC2180.html'>SC2180</a> &ndash; Bash does not support multidimensional arrays. Use 1D or associative arrays.</li>
<li><a href='SC2181.html'>SC2181</a> &ndash; Check exit code directly with e.g. `if mycmd;`, not indirectly with `$?`.</li>
<li><a href='SC2182.html'>SC2182</a> &ndash; This printf format string has no variables. Other arguments are ignored.</li>
<li><a href='SC2183.html'>SC2183</a> &ndash; This format string has 2 variables, but is passed 1 arguments.</li>
<li><a href='SC2184.html'>SC2184</a> &ndash; Quote arguments to unset so they're not glob expanded.</li>
<li><a href='SC2185.html'>SC2185</a> &ndash; Some finds don't have a default path. Specify `.` explicitly.</li>
<li><a href='SC2186.html'>SC2186</a> &ndash; tempfile is deprecated. Use mktemp instead.</li>
<li><a href='SC2187.html'>SC2187</a> &ndash; Ash scripts will be checked as Dash. Add `# shellcheck shell=dash` to silence.</li>
<li><a href='SC2188.html'>SC2188</a> &ndash; This redirection doesn't have a command. Move to its command (or use `true` as no-op).</li>
<li><a href='SC2189.html'>SC2189</a> &ndash; You can't have `|` between this redirection and the command it should apply to.</li>
<li><a href='SC2190.html'>SC2190</a> &ndash; Elements in associative arrays need index, e.g. `array=( [index]=value )` .</li>
<li><a href='SC2191.html'>SC2191</a> &ndash; The `=` here is literal. To assign by index, use `( [index]=value )` with no spaces. To keep as literal, quote it.</li>
<li><a href='SC2192.html'>SC2192</a> &ndash; This array element has no value. Remove spaces after `=` or use `""` for empty string.</li>
<li><a href='SC2193.html'>SC2193</a> &ndash; The arguments to this comparison can never be equal. Make sure your syntax is correct.</li>
<li><a href='SC2194.html'>SC2194</a> &ndash; This word is constant. Did you forget the `$` on a variable?</li>
<li><a href='SC2195.html'>SC2195</a> &ndash; This pattern will never match the case statement's word. Double check them.</li>
<li><a href='SC2196.html'>SC2196</a> &ndash; `egrep` is non-standard and deprecated. Use `grep -E` instead.</li>
<li><a href='SC2197.html'>SC2197</a> &ndash; `fgrep` is non-standard and deprecated. Use `grep -F` instead.</li>
<li><a href='SC2198.html'>SC2198</a> &ndash; Arrays don't work as operands in `[ ]`. Use a loop (or concatenate with `*` instead of `@`).</li>
<li><a href='SC2199.html'>SC2199</a> &ndash; Arrays implicitly concatenate in `[[ ]]`. Use a loop (or explicit `*` instead of `@`).</li>
<li><a href='SC2200.html'>SC2200</a> &ndash; Brace expansions don't work as operands in `[ ]`. Use a loop.</li>
<li><a href='SC2201.html'>SC2201</a> &ndash; Brace expansion doesn't happen in `[[ ]]`. Use a loop.</li>
<li><a href='SC2202.html'>SC2202</a> &ndash; Globs don't work as operands in `[ ]`. Use a loop.</li>
<li><a href='SC2203.html'>SC2203</a> &ndash; Globs are ignored in `[[ ]]` except right of `=`/`!=`. Use a loop.</li>
<li><a href='SC2204.html'>SC2204</a> &ndash; `(..)` is a subshell. Did you mean `[ .. ]`, a test expression?</li>
<li><a href='SC2205.html'>SC2205</a> &ndash; `(..)` is a subshell. Did you mean `[ .. ]`, a test expression?</li>
<li><a href='SC2206.html'>SC2206</a> &ndash; Quote to prevent word splitting/globbing, or split robustly with mapfile or `read -a`.</li>
<li><a href='SC2207.html'>SC2207</a> &ndash; Prefer `mapfile` or `read -a` to split command output (or quote to avoid splitting).</li>
<li><a href='SC2208.html'>SC2208</a> &ndash; Use `[[ ]]` or quote arguments to `-v` to avoid glob expansion.</li>
<li><a href='SC2209.html'>SC2209</a> &ndash; Use `var=$(command)` to assign output (or quote to assign string).</li>
<li><a href='SC2210.html'>SC2210</a> &ndash; This is a file redirection. Was it supposed to be a comparison or fd operation?</li>
<li><a href='SC2211.html'>SC2211</a> &ndash; This is a glob used as a command name. Was it supposed to be in `${..}`, array, or is it missing quoting?</li>
<li><a href='SC2212.html'>SC2212</a> &ndash; Use `false` instead of empty `[`/`[[` conditionals.</li>
<li><a href='SC2213.html'>SC2213</a> &ndash; getopts specified `-n`, but it's not handled by this `case`.</li>
<li><a href='SC2214.html'>SC2214</a> &ndash; This case is not specified by getopts.</li>
<li><a href='SC2215.html'>SC2215</a> &ndash; This flag is used as a command name. Bad line break or missing `[ .. ]`?</li>
<li><a href='SC2216.html'>SC2216</a> &ndash; Piping to `rm`, a command that doesn't read stdin. Wrong command or missing `xargs`?</li>
<li><a href='SC2217.html'>SC2217</a> &ndash; Redirecting to `echo`, a command that doesn't read stdin. Bad quoting or missing `xargs`?</li>
<li><a href='SC2218.html'>SC2218</a> &ndash; This function is only defined later. Move the definition up.</li>
<li><a href='SC2219.html'>SC2219</a> &ndash; Instead of `let expr`, prefer `(( expr ))` .</li>
<li><a href='SC2220.html'>SC2220</a> &ndash; Invalid flags are not handled. Add a `*)` case.</li>
<li><a href='SC2221.html'>SC2221</a> &ndash; This pattern always overrides a later one.</li>
<li><a href='SC2222.html'>SC2222</a> &ndash; This pattern never matches because of a previous pattern.</li>
<li><a href='SC2223.html'>SC2223</a> &ndash; This default assignment may cause DoS due to globbing. Quote it.</li>
<li><a href='SC2224.html'>SC2224</a> &ndash; This `mv` has no destination. Check the arguments.</li>
<li><a href='SC2225.html'>SC2225</a> &ndash; This `cp` has no destination. Check the arguments.</li>
<li><a href='SC2226.html'>SC2226</a> &ndash; This `ln` has no destination. Check the arguments, or specify `.` explicitly.</li>
<li><a href='SC2227.html'>SC2227</a> &ndash; Redirection applies to the find command itself. Rewrite to work per action (or move to end).</li>
<li><a href='SC2229.html'>SC2229</a> &ndash; This does not read `foo`. Remove `$`/`${}` for that, or use `${var?}` to quiet.</li>
<li><a href='SC2230.html'>SC2230</a> &ndash; `which` is non-standard. Use builtin `command -v` instead.</li>
<li><a href='SC2231.html'>SC2231</a> &ndash; Quote expansions in this `for` loop glob to prevent wordsplitting, e.g. `"$dir"/*.txt` .</li>
<li><a href='SC2232.html'>SC2232</a> &ndash; Can't use `sudo` with builtins like `cd`. Did you want `sudo sh -c ..` instead?</li>
<li><a href='SC2233.html'>SC2233</a> &ndash; Remove superfluous `(..)` around condition to avoid subshell overhead.</li>
<li><a href='SC2234.html'>SC2234</a> &ndash; Remove superfluous `(..)` around test command to avoid subshell overhead.</li>
<li><a href='SC2235.html'>SC2235</a> &ndash; Use `{ ..; }` instead of `(..)` to avoid subshell overhead.</li>
<li><a href='SC2236.html'>SC2236</a> &ndash; Use `-n` instead of `! -z`.</li>
<li><a href='SC2237.html'>SC2237</a> &ndash; Use `[ -n .. ]` instead of `! [ -z .. ]`.</li>
<li><a href='SC2238.html'>SC2238</a> &ndash; Redirecting to/from command name instead of file. Did you want pipes/xargs (or quote to ignore)?</li>
<li><a href='SC2239.html'>SC2239</a> &ndash; Ensure the shebang uses the absolute path to the interpreter.</li>
<li><a href='SC2240.html'>SC2240</a> &ndash; The dot command does not support arguments in sh/dash. Set them as variables.</li>
<li><a href='SC2241.html'>SC2241</a> &ndash; The exit status can only be one integer 0-255. Use stdout for other data.</li>
<li><a href='SC2242.html'>SC2242</a> &ndash; Can only exit with status 0-255. Other data should be written to stdout/stderr.</li>
<li><a href='SC2243.html'>SC2243</a> &ndash; Prefer explicit `-n` to check for output (or run command without `[`/`[[` to check for success)</li>
<li><a href='SC2244.html'>SC2244</a> &ndash; Prefer explicit `-n` to check non-empty string (or use `=`/`-ne` to check boolean/integer).</li>
<li><a href='SC2245.html'>SC2245</a> &ndash; -d only applies to the first expansion of this glob. Use a loop to check any/all.</li>
<li><a href='SC2246.html'>SC2246</a> &ndash; This shebang specifies a directory. Ensure the interpreter is a file.</li>
<li><a href='SC2247.html'>SC2247</a> &ndash; Flip leading `$` and `"` if this should be a quoted substitution.</li>
<li><a href='SC2248.html'>SC2248</a> &ndash; Prefer double quoting even when variables don't contain special characters.</li>
<li><a href='SC2249.html'>SC2249</a> &ndash; Consider adding a default `*)` case, even if it just exits with error.</li>
<li><a href='SC2250.html'>SC2250</a> &ndash; Prefer putting braces around variable references even when not strictly required.</li>
<li><a href='SC2251.html'>SC2251</a> &ndash; This `!` is not on a condition and skips errexit. Use `&& exit 1` instead, or make sure `$?` is checked.</li>
<li><a href='SC2252.html'>SC2252</a> &ndash; You probably wanted `&&` here, otherwise it's always true.</li>
<li><a href='SC2253.html'>SC2253</a> &ndash; Use `-R` to recurse, or explicitly `a-r` to remove read permissions.</li>
<li><a href='SC2254.html'>SC2254</a> &ndash; Quote expansions in case patterns to match literally rather than as a glob.</li>
<li><a href='SC2255.html'>SC2255</a> &ndash; `[ ]` does not apply arithmetic evaluation. Evaluate with `$((..))` for numbers, or use string comparator for strings.</li>
<li><a href='SC2256.html'>SC2256</a> &ndash; This translated string is the name of a variable. Flip leading `$` and `"` if this should be a quoted substitution.</li>
<li><a href='SC2257.html'>SC2257</a> &ndash; Arithmetic modifications in command redirections may be discarded. Do them separately.</li>
<li><a href='SC2259.html'>SC2259</a> &ndash; This redirection overrides piped input. To use both, merge or pass filenames.</li>
<li><a href='SC2260.html'>SC2260</a> &ndash; This redirection overrides the output pipe. Use `tee` to output to both.</li>
<li><a href='SC2261.html'>SC2261</a> &ndash; Multiple redirections compete for stdout. Use `cat`, `tee`, or pass filenames instead.</li>
<li><a href='SC2262.html'>SC2262</a> &ndash; This alias can't be defined and used in the same parsing unit. Use a function instead.</li>
<li><a href='SC2263.html'>SC2263</a> &ndash; Since they're in the same parsing unit, this command will not refer to the previously mentioned alias.</li>
<li><a href='SC2264.html'>SC2264</a> &ndash; This function unconditionally re-invokes itself. Missing `command`?</li>
<li><a href='SC2265.html'>SC2265</a> &ndash; Use && for logical AND. Single & will background and return true.</li>
<li><a href='SC2266.html'>SC2266</a> &ndash; Use && for logical AND. Single & will background and return true.</li>
<li><a href='SC2267.html'>SC2267</a> &ndash; GNU `xargs -i` is deprecated in favor of `-I{}`</li>
<li><a href='SC2268.html'>SC2268</a> &ndash; Avoid x-prefix in comparisons as it no longer serves a purpose.</li>
<li><a href='SC2269.html'>SC2269</a> &ndash; This variable is assigned to itself, so the assignment does nothing.</li>
<li><a href='SC2270.html'>SC2270</a> &ndash; To assign positional parameters, use `set -- first second ..` (or use `[ ]` to compare).</li>
<li><a href='SC2271.html'>SC2271</a> &ndash; For indirection, use arrays, `declare "var$n=value"`, or (for sh) read/eval</li>
<li><a href='SC2272.html'>SC2272</a> &ndash; Command name contains `==`. For comparison, use `[ "$var" = value ]`.</li>
<li><a href='SC2273.html'>SC2273</a> &ndash; Sequence of `===`s found. Merge conflict or intended as a commented border?</li>
<li><a href='SC2274.html'>SC2274</a> &ndash; Command name starts with `===`. Intended as a commented border?</li>
<li><a href='SC2275.html'>SC2275</a> &ndash; Command name starts with `=`. Bad line break?</li>
<li><a href='SC2276.html'>SC2276</a> &ndash; This is interpreted as a command name containing `=`. Bad assignment or comparison?</li>
<li><a href='SC2277.html'>SC2277</a> &ndash; Use `BASH_ARGV0` to assign to `$0` in bash (or use `[ ]` to compare).</li>
<li><a href='SC2278.html'>SC2278</a> &ndash; `$0` can't be assigned in Ksh (but it does reflect the current function).</li>
<li><a href='SC2279.html'>SC2279</a> &ndash; `$0` can't be assigned in Dash. This becomes a command name.</li>
<li><a href='SC2280.html'>SC2280</a> &ndash; `$0` can't be assigned this way, and there is no portable alternative.</li>
<li><a href='SC2281.html'>SC2281</a> &ndash; Don't use `$`/`${}` on the left side of assignments.</li>
<li><a href='SC2282.html'>SC2282</a> &ndash; Variable names can't start with numbers, so this is interpreted as a command.</li>
<li><a href='SC2283.html'>SC2283</a> &ndash; Use `[ ]` to compare values, or remove spaces around `=` to assign (or quote `'='` if literal).</li>
<li><a href='SC2284.html'>SC2284</a> &ndash; Use `[ x = y ]` to compare values (or quote `'=='` if literal).</li>
<li><a href='SC2285.html'>SC2285</a> &ndash; Remove spaces around `+=` to assign (or quote `'+='` if literal).</li>
<li><a href='SC2286.html'>SC2286</a> &ndash; This empty string is interpreted as a command name. Double check syntax (or use 'true' as a no-op).</li>
<li><a href='SC2287.html'>SC2287</a> &ndash; This is interpreted as a command name ending with '/'. Double check syntax.</li>
<li><a href='SC2288.html'>SC2288</a> &ndash; This is interpreted as a command name ending with apostrophe. Double check syntax.</li>
<li><a href='SC2289.html'>SC2289</a> &ndash; This is interpreted as a command name containing a linefeed. Double check syntax.</li>
<li><a href='SC2290.html'>SC2290</a> &ndash; Remove spaces around = to assign.</li>
<li><a href='SC2291.html'>SC2291</a> &ndash; Quote repeated spaces to avoid them collapsing into one.</li>
<li><a href='SC2292.html'>SC2292</a> &ndash; Prefer `[[ ]]` over `[ ]` for tests in Bash/Ksh.</li>
<li><a href='SC2293.html'>SC2293</a> &ndash; When eval'ing @Q-quoted words, use * rather than @ as the index.</li>
<li><a href='SC2294.html'>SC2294</a> &ndash; eval negates the benefit of arrays. Drop eval to preserve whitespace/symbols (or eval as string).</li>
<li><a href='SC2295.html'>SC2295</a> &ndash; Expansions inside `${..}` need to be quoted separately, otherwise they will match as a pattern.</li>
<li><a href='SC2296.html'>SC2296</a> &ndash; Parameter expansions can't start with `{`. Double check syntax.</li>
<li><a href='SC2297.html'>SC2297</a> &ndash; Double quotes must be outside `${}`: `${"invalid"}` vs `"${valid}"`.</li>
<li><a href='SC2298.html'>SC2298</a> &ndash; `${$x}` is invalid. For expansion, use ${x}. For indirection, use arrays, ${!x} or (for sh) eval.</li>
<li><a href='SC2299.html'>SC2299</a> &ndash; Parameter expansions can't be nested. Use temporary variables.</li>
<li><a href='SC2300.html'>SC2300</a> &ndash; Parameter expansion can't be applied to command substitutions. Use temporary variables.</li>
<li><a href='SC2301.html'>SC2301</a> &ndash; Parameter expansion starts with unexpected quotes. Double check syntax.</li>
<li><a href='SC2302.html'>SC2302</a> &ndash; This loops over values. To loop over keys, use `"${!array[@]}"`.</li>
<li><a href='SC2303.html'>SC2303</a> &ndash; `i` is an array value, not a key. Use directly or loop over keys instead.</li>
<li><a href='SC2304.html'>SC2304</a> &ndash; `*` must be escaped to multiply: `\*`. Modern `$((x * y))` avoids this issue.</li>
<li><a href='SC2305.html'>SC2305</a> &ndash; Quote regex argument to expr to avoid it expanding as a glob.</li>
<li><a href='SC2306.html'>SC2306</a> &ndash; Escape glob characters in arguments to expr to avoid pathname expansion.</li>
<li><a href='SC2307.html'>SC2307</a> &ndash; 'expr' expects 3+ arguments but sees 1. Make sure each operator/operand is a separate argument, and escape <>&|.</li>
<li><a href='SC2308.html'>SC2308</a> &ndash; `expr length` has unspecified results. Prefer `${#var}`.</li>
<li><a href='SC2309.html'>SC2309</a> &ndash; -eq treats this as a variable. Use = to compare as string (or expand explicitly with $var)</li>
<li><a href='SC2310.html'>SC2310</a> &ndash; This function is invoked in an 'if' condition so set -e will be disabled. Invoke separately if failures should cause the script to exit.</li>
<li><a href='SC2311.html'>SC2311</a> &ndash; Bash implicitly disabled set -e for this function invocation because it's inside a command substitution. Add set -e; before it or enable inherit_errexit.</li>
<li><a href='SC2312.html'>SC2312</a> &ndash; Consider invoking this command separately to avoid masking its return value (or use '|| true' to ignore).</li>
<li><a href='SC2313.html'>SC2313</a> &ndash; Quote array indices to avoid them expanding as globs.</li>
<li><a href='SC2314.html'>SC2314</a> &ndash; In bats, `!` does not cause a test failure.</li>
<li><a href='SC2315.html'>SC2315</a> &ndash; In bats, `!` does not cause a test failure. Fold the `!` into the conditional!</li>
<li><a href='SC2316.html'>SC2316</a> &ndash; This applies local to the variable named readonly, which is probably not what you want. Use a separate command or the appropriate `declare` options instead.</li>
<li><a href='SC2317.html'>SC2317</a> &ndash; Command appears to be unreachable. Check usage (or ignore if invoked indirectly).</li>
<li><a href='SC2318.html'>SC2318</a> &ndash; This assignment is used again in this `declare`, but won't have taken effect. Use two `declare`s.</li>
<li><a href='SC2319.html'>SC2319</a> &ndash; This `$?` refers to a condition, not a command. Assign to a variable to avoid it being overwritten.</li>
<li><a href='SC2320.html'>SC2320</a> &ndash; This `$?` refers to echo/printf, not a previous command. Assign to variable to avoid it being overwritten.</li>
<li><a href='SC2321.html'>SC2321</a> &ndash; Array indices are already arithmetic contexts. Prefer removing the `$((` and `))`.</li>
<li><a href='SC2322.html'>SC2322</a> &ndash; In arithmetic contexts, `((x))` is the same as `(x)`. Prefer only one layer of parentheses.</li>
<li><a href='SC2323.html'>SC2323</a> &ndash; `a[(x)]` is the same as `a[x]`. Prefer not wrapping in additional parentheses.</li>
<li><a href='SC2324.html'>SC2324</a> &ndash; var+=1 will append, not increment. Use (( var += 1 )), declare -i var, or quote number to silence.</li>
<li><a href='SC2325.html'>SC2325</a> &ndash; Multiple ! in front of pipelines are a bash/ksh extension. Use only 0 or 1.</li>
<li><a href='SC2326.html'>SC2326</a> &ndash; ! is not allowed in the middle of pipelines. Use command group as in `cmd | { ! cmd; }` if necessary.</li>
<li><a href='SC2327.html'>SC2327</a> &ndash; This command substitution will be empty because the command's output gets redirected away.</li>
<li><a href='SC2328.html'>SC2328</a> &ndash; This redirection takes output away from the command substitution.</li>
<li><a href='SC2329.html'>SC2329</a> &ndash; This function is never invoked. Check usage (or ignored if invoked indirectly).</li>
<li><a href='SC3001.html'>SC3001</a> &ndash; In POSIX sh, process substitution is undefined.</li>
<li><a href='SC3002.html'>SC3002</a> &ndash; In POSIX sh, extglob is undefined.</li>
<li><a href='SC3003.html'>SC3003</a> &ndash; In POSIX sh, `$'..'` is undefined.</li>
<li><a href='SC3004.html'>SC3004</a> &ndash; In POSIX sh, $".." is undefined</li>
<li><a href='SC3005.html'>SC3005</a> &ndash; In POSIX sh, arithmetic for loops are undefined.</li>
<li><a href='SC3006.html'>SC3006</a> &ndash; In POSIX sh, standalone `((..))` is undefined.</li>
<li><a href='SC3007.html'>SC3007</a> &ndash; In POSIX sh, `$[..]` in place of `$((..))` is undefined.</li>
<li><a href='SC3008.html'>SC3008</a> &ndash; In POSIX sh, select loops are undefined.</li>
<li><a href='SC3009.html'>SC3009</a> &ndash; In POSIX `sh`, brace expansion is undefined.</li>
<li><a href='SC3010.html'>SC3010</a> &ndash; In POSIX sh, `[[ ]]` is undefined.</li>
<li><a href='SC3011.html'>SC3011</a> &ndash; In POSIX sh, here-strings are undefined.</li>
<li><a href='SC3012.html'>SC3012</a> &ndash; In POSIX sh, lexicographical `\<` is undefined.</li>
<li><a href='SC3013.html'>SC3013</a> &ndash; In POSIX sh, `-nt` is undefined.</li>
<li><a href='SC3014.html'>SC3014</a> &ndash; In POSIX sh, `==` in place of `=` is undefined.</li>
<li><a href='SC3015.html'>SC3015</a> &ndash; In POSIX sh, `=~` regex matching is undefined.</li>
<li><a href='SC3016.html'>SC3016</a> &ndash; In POSIX sh, unary `-v` (in place of `[ -n "${var+x}" ]`) is undefined.</li>
<li><a href='SC3017.html'>SC3017</a> &ndash; In POSIX sh, unary `-a` in place of `-e` is undefined.</li>
<li><a href='SC3018.html'>SC3018</a> &ndash; In POSIX sh, `++` is undefined.</li>
<li><a href='SC3019.html'>SC3019</a> &ndash; In POSIX sh, exponentials are undefined.</li>
<li><a href='SC3020.html'>SC3020</a> &ndash; In POSIX sh, `&>` is undefined.</li>
<li><a href='SC3021.html'>SC3021</a> &ndash; In POSIX sh, `>& filename` (as opposed to `>& fd`) is undefined.</li>
<li><a href='SC3022.html'>SC3022</a> &ndash; In POSIX sh, named file descriptors is undefined.</li>
<li><a href='SC3023.html'>SC3023</a> &ndash; In POSIX sh, FDs outside of 0-9 are undefined.</li>
<li><a href='SC3024.html'>SC3024</a> &ndash; In POSIX sh, `+=` is undefined.</li>
<li><a href='SC3025.html'>SC3025</a> &ndash; In POSIX sh, `/dev/{tcp,udp}` is undefined.</li>
<li><a href='SC3026.html'>SC3026</a> &ndash; In POSIX sh, `^` in place of `!` in glob bracket expressions is undefined.</li>
<li><a href='SC3028.html'>SC3028</a> &ndash; In POSIX sh, VARIABLE is undefined.</li>
<li><a href='SC3029.html'>SC3029</a> &ndash; In POSIX sh, `|&` in place of `2>&1 |` is undefined.</li>
<li><a href='SC3030.html'>SC3030</a> &ndash; In POSIX sh, arrays are undefined.</li>
<li><a href='SC3031.html'>SC3031</a> &ndash; In POSIX sh, redirecting from/to globs is undefined.</li>
<li><a href='SC3032.html'>SC3032</a> &ndash; In POSIX sh, coproc is undefined.</li>
<li><a href='SC3033.html'>SC3033</a> &ndash; In POSIX sh, naming functions outside [a-zA-Z_][a-zA-Z0-9_]* is undefined.</li>
<li><a href='SC3034.html'>SC3034</a> &ndash; In POSIX sh, `$(<file)` is undefined.</li>
<li><a href='SC3035.html'>SC3035</a> &ndash; In POSIX sh, `` `<file` `` is undefined.</li>
<li><a href='SC3036.html'>SC3036</a> &ndash; In Dash, echo flags besides -n are not supported.</li>
<li><a href='SC3037.html'>SC3037</a> &ndash; In POSIX sh, echo flags are undefined.</li>
<li><a href='SC3038.html'>SC3038</a> &ndash; In POSIX sh, exec flags are undefined.</li>
<li><a href='SC3039.html'>SC3039</a> &ndash; In POSIX sh, `let` is undefined.</li>
<li><a href='SC3040.html'>SC3040</a> &ndash; In POSIX sh, set option *[name]* is undefined.</li>
<li><a href='SC3041.html'>SC3041</a> &ndash; In POSIX sh, set flag `-E` is undefined</li>
<li><a href='SC3042.html'>SC3042</a> &ndash; In POSIX sh, set flag `--default` is undefined</li>
<li><a href='SC3043.html'>SC3043</a> &ndash; In POSIX sh, `local` is undefined.</li>
<li><a href='SC3044.html'>SC3044</a> &ndash; In POSIX sh, `declare` is undefined.</li>
<li><a href='SC3045.html'>SC3045</a> &ndash; In POSIX sh, some-command-with-flag is undefined.</li>
<li><a href='SC3046.html'>SC3046</a> &ndash; In POSIX sh, `source` in place of `.` is undefined.</li>
<li><a href='SC3047.html'>SC3047</a> &ndash; In POSIX sh, trapping ERR is undefined.</li>
<li><a href='SC3048.html'>SC3048</a> &ndash; In POSIX sh, prefixing signal names with 'SIG' is undefined.</li>
<li><a href='SC3049.html'>SC3049</a> &ndash; In POSIX sh, using lower/mixed case for signal names is undefined.</li>
<li><a href='SC3050.html'>SC3050</a> &ndash; In POSIX sh, `printf %q` is undefined.</li>
<li><a href='SC3051.html'>SC3051</a> &ndash; In POSIX sh, `source` in place of `.` is undefined</li>
<li><a href='SC3052.html'>SC3052</a> &ndash; In POSIX sh, arithmetic base conversion is undefined</li>
<li><a href='SC3053.html'>SC3053</a> &ndash; In POSIX sh, indirect expansion is undefined.</li>
<li><a href='SC3054.html'>SC3054</a> &ndash; In POSIX sh, array references are undefined.</li>
<li><a href='SC3055.html'>SC3055</a> &ndash; In POSIX sh, array key expansion is undefined.</li>
<li><a href='SC3056.html'>SC3056</a> &ndash; In POSIX sh, name matching prefixes are undefined.</li>
<li><a href='SC3057.html'>SC3057</a> &ndash; In POSIX sh, string indexing is undefined.</li>
<li><a href='SC3059.html'>SC3059</a> &ndash; </li>
<li><a href='SC3060.html'>SC3060</a> &ndash; In POSIX sh, string replacement is undefined.</li>
<li><a href='SCXXXX.html'>SCXXXX</a> &ndash; </li>
<li><a href='Template.html'>Template</a> &ndash; (Message goes here, use `code` and *foo* wisely)</li>
<li><a href='TravisCI.html'>TravisCI</a> &ndash; </li>
<li><a href='checkstyle2text.html'>checkstyle2text</a> &ndash; </li>
<li><a href='severity.html'>severity</a> &ndash; Severity</li>
</ul>
